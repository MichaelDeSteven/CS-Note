# 算法与数据结构总结

> 常用算法以及思想包括了**二分、前缀和、差分、枚举、递归递推、动态规划、双指针、排序、贪心、图论相关的包括DFS、BFS、最短路**、二分图、最小生成树等、数论相关的有**辗转相除法、拓展欧几里得、线性筛素数**等、还有一些博弈论的相关结论、相关字符串算法
>
> 数据结构包括了：数组**链表**、**队列、栈、堆**的概念和应用（包括了**单调队列**、**单调栈**）、哈希表的应用、树包括了**二叉搜索树**，**Trie**，还有一些复杂的（B树、B+树、平衡树、红黑树这些了解即可），图的数据结构（基于邻接矩阵、邻接表、前向星的**建图**方法）、**并查集**、树状数组与线段树简单应用
>
> 我们还可以利用相关技巧如**位运算**、**哨兵**写出更简洁的代码
>
> 本篇用于总结以上算法与数据结构以及相关技巧，再结合其应用来更好地理解与巩固基础



## 算法概述

### 算法

> 定义：给出确定和完整地指令，再给定一组输出，算法能够在有限地时间获得输出结果

#### 性质

* 有限性
* 确定性
* 有输入输出
* 有效性

#### 常用的算法思想

递推、递归、枚举、贪心、分治、迭代、回溯



#### 时间复杂度和空间复杂度

* 复杂度一般用O表示法，表示一个函数运行的渐进上界

![](http://static.oschina.net/uploads/space/2014/0426/210036_kKPH_1246663.png)



#### 时间复杂度反推算法

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95.png?raw=true)

## 数据结构概述

### 数据结构

> 定义：计算机中存储与组织特定关系的数据元素的方式

#### 逻辑结构

> 反映数据之间的逻辑关系

1. 线性结构：元素之间一对一的关系，
2. 树形结构：元素之间一对多或者多对一的关系
3. 图形结构：元素之间多对多的关系

#### 物理结构

1. 顺序存储：元素在内存中按顺序存放，可随机存取元素，插入或删除需要移动元素
2. 链接存储：由数据域与指针域构成，逻辑上相邻而物理上不必相邻，插入、删除灵活
3. 索引存储：除了存储结点信息外，还需要建立附加的索引表来表示结点的地址，索引表由若干个索引项组成
4. 散列存储：由键值对组成，通过关键字来存取值







## 二分

> 二分查找是一种高效率地查找，经典应用是在有序排列的数组找到目标值
>
> 二分查找的本质是找到某种性质，能将顺序表划分了两段，其中一段符合该性质，另一段不符合性质，即具有二段性



### 模板

整数二分模板

```c++
// 查找区间右端点
int low = 0, high = n - 1;
while (low < high) {
    int mid = low + high + 1 >> 1;
    if (nums[mid] <= target) {				
        ll = mid;
    } else {
        rr = mid - 1;
    }
}


// 查找区间左端点
while (low < high) {
    int mid = low + high >> 1;
    if (nums[mid] >= target) {				
        rr = mid;
    } else {
        ll = mid + 1;
    }
}
```



浮点数二分模板

```c++
while (high - low > 1e-6) {							// 终止的条件为精度
    double mid = (low + high) / 2;					// 由于是浮点数，不能用右移的方式
    if (num[mid] >= target) {
        rr = mid;
    } else {
        ll = mid;
    }
}
```



### 相关习题

| 题目链接                                                     | 二分依据                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [704.二分查找](https://leetcode-cn.com/problems/binary-search/) | 有序数组，寻找区间端点                                       |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | 有序数组，第一个位置即第一个大于等于目标值(区间向左缩)，最后一个位置即最后一个小于等于目标值(区间向右缩) |
| [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/) | 某点下标与值相同，缺失的数字则一定在右区间，反之则一定在左区间（区间向左缩） |
| [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)    | 由于只保留整数部分，可以看作需要查找最大的mid满足x >= mid^2（区间向右缩） |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) | 目标值不存在数组则按顺序插入，即寻找最后一个小于等于目标值的位置（区间向右缩） |
| [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/) | 三分可解决，用二分则通过mid与mid + 1比较                     |
| [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/) | nums[mid] > nums[mid + 1],mid左区间(包含mid)必定存在峰值，区间向左缩 |
| [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/) | 二分套二分，先用二分寻找峰值，峰值左右两边再二分找目标值     |
| [1237. 找出给定方程的正整数解](https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/) | 枚举变量x，由于f(x,y)为严格单调，因此可以对y进行二分，使得f(x, y) - z == 0 |
| [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/) | 寻找第一个出错的版本，区间向左缩，需要考虑mid计算溢出        |
| [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) | min{前一部分数组} > max{后一部分数组}因此下标为mid的值与右区间端点比较，具有二段性，小于右区间端点，最小值在mid左边，区间向左缩 |
| [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，右指针向左移动一位排除相同的值 |
| [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) | 分析可得min{前一部分数组} > max{后一部分数组}，二分找到旋转点，选择一个区间进行二分 |
| [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，需要特判从结尾排除与nums[0]相同的值 |
| [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/) | 枚举运载能力x，若d天内x能完成，则大于等于x的运载能力都能完成，即具有二段性 |
| [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182) | 枚举最大值，每个段子数组的和不应该超过最大值，若无法找到这样的情况则最大值不能再枚举更小的数，即具有二段性 |
| [1221. 四平方和](https://www.acwing.com/problem/content/1223/) | 预处理二元组，根据主键顺序排序，枚举前两个的平方和再根据二元组的大小进行二分 |
| [1227. 分巧克力](https://www.acwing.com/problem/content/1229/) | 对巧克力边长进行二分                                         |
| [730. 机器人跳跃问题](https://www.acwing.com/problem/content/732/) | 对初始能量进行二分                                           |



## 前缀和、差分

> 前缀和运用了递推的思想，经典的空间复杂度换时间时间复杂度的策略

### 前缀和

#### 一维前缀和



#### 二位前缀和



### 差分

#### 一维差分



#### 二维差分



### 相关习题

| 题目链接                                                     | 思路                                   |
| ------------------------------------------------------------ | -------------------------------------- |
| [1236. 递增三元组](https://www.acwing.com/problem/content/1238/) | 利用前缀和统计大于等于和小于等于bi的数 |
| [1230. K倍区间](https://www.acwing.com/problem/content/1232/) | 抓住s[i] % k = s[j] % k条件            |
| [102. 最佳牛围栏](https://www.acwing.com/problem/content/104/) | 前缀和+二分的应用                      |
| [796. 子矩阵的和](https://www.acwing.com/problem/content/798/) | 二维前缀和模板                         |
| [99. 激光炸弹](https://www.acwing.com/problem/content/101/)  | 二维前缀和应用                         |
| [797.差分](https://www.acwing.com/problem/content/799/)      | 模板题                                 |
| [101. 最高的牛](https://www.acwing.com/problem/content/103/) |                                        |

## 双指针和排序

### 双指针



> 双指针的思想应用范围很广





### 排序



#### 0. 十大排序算法比较

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

#### 1. 插入排序



1. 算法思路
   * 从未排序中的数组选择一个元素e插入到已排序好的数组中
   * 按倒序顺序遍历已排序好的数组（遍历的值设为x）逐个与e进行比较
   * 若x大于元素e，则将将x向后移动一位，若x小于等于则将e插入该位置
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```c++
void insert(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        int j = i, e = arr[i];
        while (j > l && arr[j - 1] > e) arr[j] = arr[j - 1], j--;
        arr[j] = e;
    }
}
```



#### 2. 选择排序

1. 算法思路

   * 每次从未排序的数组中选择一个最小的元素e
   * 将元素e插入到已排序数组的末尾
   * 重复上述步骤，直到所有元素都已排序

2.  代码实现

   ```c++
   void select(int l, int r, int arr[]) {
       for (int i = l; i <= r; i++) {
           int inx = i;
           for (int j = i; j <= r; j++) {
               if (arr[j] < arr[inx]) inx = j;
           }
           swap(arr[inx], arr[i]);
       }
   }
   ```



#### 3. 希尔排序

> 简单插入排序的改良版本,又称缩小增量排序，实质是分组的插入排序
>
> * 希尔排序的时间复杂度和增量序列是相关的



```cpp
void shell(int l, int r, int arr[]) {
    int len = r - l + 1;
    for (int i = len >> 1; i > 0; i >>= 1) {
        for (int j = i; j <= r; j++) {
            int k = j, e = arr[k];
            while (k >= i && arr[k - i] > e) arr[k] = arr[k - i], k -= i;
            arr[k] = e;
        }
    }
}
```







#### 4. 冒泡排序

1. 算法思路 

   * 每次从头开始相邻两个元素比较
   * 若前一个元素大于后一个元素则交换
   * 到数组结尾则完成这一轮的操作
   * 若某一轮次未有交换发生则说明该数组已排好序，提前退出
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```cpp
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);
        }
    }
}



// 优化的代码
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        bool flag = true;
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag = false;
                swap(arr[j], arr[j + 1]);
            }
        }
        if (flag) break;
    }
}
```





#### 5. 快速排序

1. 算法思路

   * 确定一个基准值pivot
   * 小于等于pivot的值放在数组前半部分，大于等于pivot的值放在数组后半部分
   * 分别对数组前半部分和后半部分递归，直到区间长度为1

2. 代码实现

```cpp
void quick(int l, int r, int arr[]) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = arr[i + j >> 1];
    
    while (i < j) {
        do i++; while (arr[i] < x);
        do j--; while (arr[j] > x);
        if (i < j) swap(arr[i], arr[j]);
    }

    quick(l, j, arr), quick(j + 1, r, arr);
}
```







#### 6. 归并排序

> 归并排序是稳定的排序，时间复杂度也是稳定的，其代价是需要额外的内存空间

![](https://camo.githubusercontent.com/ce0f02cdc800ad02551271b79ecc6a778280a41b/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f313032343535352f3230313631322f313032343535352d32303136313231383136333132303135312d3435323238333735302e706e67)

1. 算法思路

   * 将区间一分为二，对两个区间进行递归，直到区间大小为1，自顶向下
   * 对这两个区间进行归并（这两个区间都是有序的），放在另一个数组中

   * 再将另一个数组复制到原数组

2. 代码实现

```cpp
void merge(int l, int r, int arr[]) {
    if (l >= r) return;
    int mid = l + r >> 1, i = l, j = mid + 1, k = 0;
    merge(l, mid, arr), merge(mid + 1, r, arr);
    
    while (i <= mid && j <= r) {
        if (arr[i] > arr[j]) cop[k++] = arr[j++];
        else cop[k++] = arr[i++];
    }
    
    while (i <= mid) cop[k++] = arr[i++];
    while (j <= r) cop[k++] = arr[j++];
    
    for (int i = l, k = 0; i <= r; i++, k++) arr[i] = cop[k];
}
```





#### 7. 堆排序

> 借助堆的数据结构



**参考资料**：[十大经典排序](https://www.cnblogs.com/onepixel/articles/7674659.html)





## 高精度与离散化



### 高精度

> 包含了高精度的大整数加减乘除运算

* A：高精度数字如何存储？

  Q：数组低地址存低位

#### 高精度加法



```cpp
vector<int> add(vector<int>& a, vector<int>& b) {
    int res = 0;
    vector<int> c;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) res += a[i];
        if (i < b.size()) res += b[i];
        c.push_back(res % 10);
        res /= 10;
    }
    if (res) c.push_back(res);
    return c;
}
```



#### 高精度减法

```c++
// 需要保证a >= b,且a、b均为非负数
vector<int> sub(vector<int>& a, vector<int>& b) {
    vector<int> c;
    int res = 0;
    for (int i = 0; i < a.size(); i++) {
        res = a[i] - res;
        if (i < b.size()) res -= b[i];
        c.push_back((res + 10) % 10);
        if (res < 0) res = 1;
        else res = 0;
    }
    // 去除前导0
    while (c.size() > 1 && c[c.size() - 1] == 0) c.pop_back();
    return c;
}
```



#### 高精度乘法



#### 高精度除法





### 离散化

> 离散化的本质是映射。离散化的意义是将区间范围很大，而用到的值的个数少，且需要保持其值相对大小的集合进行映射



```cpp
// 离散化前的准备
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) { // 找到第一个大于等于x的位置
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}


// 哈希表映射
unordered_map<int, int> ma				// 采用unordered_map进行映射
for (auto i : all) ma[i] = ++cnt;       // 映射到1, 2, ...n
```





## 数组与链表







## 队列与栈

### 模板

#### 普通队列模板

* 队列具有FIFO(First In First Out)特点

```cpp
// 普通队列, tt表示队尾指针，hh表示队头指针
int queue[N], tt = -1, hh = 0;

// 队尾入队
queue[++tt] = e;

// 是否为空
若hh > tt 则说明队列为空
    
// 队头出队
hh++
    
// 查询队头元素
queue[hh]
```



#### 栈模板

* 堆栈具有FILO(First In Last Out)特点

```cpp
// 普通堆栈，hh表示栈顶指针
int stack[N], hh = 0;

// 判断是否为空
hh等于0则为空
    
// 入栈
stack[++hh] = e;

// 出栈
--hh;

// 查询栈顶元素
stack[hh]
    
// 查询大小
hh
```



#### 单调栈模板

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int hh = 0;
for (int i = 1; i <= n; i ++ ) {
    while (hh && check(stk[hh], i)) tt -- ;
    stk[ ++ hh] = i;
}
```



#### 单调队列模板

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ ) {
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```





### 相关习题

| 题目链接                                                     | 说明                                           |
| ------------------------------------------------------------ | ---------------------------------------------- |
| [828. 模拟栈](https://www.acwing.com/problem/content/description/830/) | 模板                                           |
| [830. 单调栈](https://www.acwing.com/problem/content/832/)   | 利用单调栈，找到每个数离它左边最近的比它小的数 |
| [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) | 利用栈验证                                     |
| [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) |                                                |
| [150. 括号画家](https://www.acwing.com/problem/content/152/) | 求最长连续有效括号                             |
| [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/) |                                                |
| [41. 包含min函数的栈](https://www.acwing.com/problem/content/90/) | 利用单调栈来维护最小值                         |
| [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/) | 模拟                                           |
| [129. 火车进栈](https://www.acwing.com/activity/content/problem/content/364/1/) | dfs+模拟栈                                     |
| [131. 直方图中最大的矩形](https://www.acwing.com/activity/content/problem/content/366/1/) | 单调栈的应用                                   |
| [152. 城市游戏](https://www.acwing.com/problem/content/154/) | 上题拓展                                       |
| [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) |                                                |
| [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) |                                                |
| [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/) |                                                |
| [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/) |                                                |
| [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) |                                                |
| [151. 表达式计算4](https://www.acwing.com/problem/content/153/) | 栈在表达式中的应用                             |
| [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) | 表达式计算简单版                               |
| [829. 模拟队列](https://www.acwing.com/problem/content/description/831/) | 模板                                           |
| [154. 滑动窗口](https://www.acwing.com/problem/content/description/156/) | 利用单调队列，在O(1)时间复杂度内找到区间的最值 |
| [135. 最大子序和](https://www.acwing.com/problem/content/description/137/) | 前缀和+单调队列                                |
|                                                              |                                                |

## 树

### 树的定义及其术语

> 定义：除了根结点以外，每个结点有且仅有一个父结点，都拥有多个孩子结点，每个结点及其该结点的孩子结点组成的结合其结构也符合树的定义



* 叶子结点：无孩子的结点

* 结点的度：指孩子节点的个数

### 二叉树

> 二叉树的定义： 二叉树**要么为空**，要么每个结点**最多**只含有**两个直接孩子结点**，这两个直接孩子结点及其它们的孩子结点也分别称为左右子树，该左右子树符合二叉树的定义



#### 二叉树的性质

* 性质1

  二叉树第i层最多有$2^{i-1}$ 个结点, $i>=1$

* 性质2

  深度为k的二叉树最多有$2^k-1$个结点

* 性质3

  定义度为i的结点为$n_i$ ，则二叉树满足${n_2} = {n_0} + 1$ 

  > 证明方法：
  >
  > 1. 首先树的总边数e与总结点数是满足于$e = n - 1$
  >
  > 上面的关系式可以理解成除了根节点以外，所有结点都对应一条与父结点的边，反过来，所有结点直接孩子的个数有关系式$n_1 + 2n_2 = e$
  >
  > 2. 总结点数有关系式$n = n_0 + n_1 + n_2$
  >
  > 3. $n_1 + 2n_2 + 1 = n_0 + n_1 + n_2$
  >
  >    即有${n_2} = {n_0} + 1$

  

* 性质4

  具有n个结点的完全二叉树的深度为$\lfloor log_2n \rfloor + 1$

* 性质5

  完全二叉树中的某结点为i，则

  1）若存在父结点，则父结点编号为$[i / 2]$

  2）若存在左子结点，则编号为$2i$

  3）若存在右子结点，则编号为$2i+1$

#### 完全二叉树与满二叉树



> 完全二叉树定义：按从上到下从左到右的顺序，从1开始，给二叉树每个结点依次编号，若结点数为n，则所有结点**在且仅在**编号1到编号n中

> 满二叉树的定义：深度为k的二叉树中，有且仅有$2^k - 1$个结点

![](https://bkimg.cdn.bcebos.com/pic/7acb0a46f21fbe0961cdc7e561600c338644adab?x-bce-process=image/crop,x_0,y_3,w_600,h_396/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

### 二叉树的存储

##### 物理存储结构

1. 数组存储（适合于完全二叉树）
2. 链表存储

##### 逻辑存储结构

* 双亲表示法

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923203304500-1066380837.png)

* 孩子表示法(**常用**)

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204350058-771438158.png)

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204035397-1294931058.png)



* 孩子兄弟表示法：

  ![img](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923212046972-354309866.png)



![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204256034-1713840703.png)







### 二叉树的遍历

树的结构体定义如下

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
```



#### 先序遍历

**递归版先序遍历步骤**

1. 遍历根结点

2. 遍历左子树

3. 遍历右子树

**迭代版先序遍历步骤**

1. 初始化一个空栈，将指针p置为根结点
2. 若指针p不为空，则先打印该结点的值，再将指针p压入栈中
3. 指针p更新为p的左子结点，重复步骤2直到p为空
4. 若栈不为空，将指针p更新为栈顶结点的右子结点，弹出栈顶元素
5. 重复2-4步骤，直到指针p为空且栈为空



**递归代码实现**

```cpp
void preorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    cout << root->val << endl;
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}
```



**迭代代码实现**

```cpp
void preorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        TreeNode* p = root;
        while (!stk.empty() || p) {
            while (p) {
                res.push_back(p->val);					// 先打印
                stk.push(p);
                p = p->left;
            }
            if (!stk.empty()) {
                p = stk.top()->right;
                stk.pop();
            }
        }
}
```





#### 中序遍历

**递归版先序遍历步骤**

1. 遍历左子树

2. 遍历根结点

3. 遍历右子树

**迭代版中序遍历步骤**

1. 初始化一个空栈，将指针p置为根结点
2. 若指针p不为空，则将指针p压入栈中
3. 指针p更新为p的左子结点，重复步骤2直到p为空
4. 若栈不为空，打印栈顶结点的值，再将指针p更新为栈顶结点的右子结点，弹出栈顶元素
5. 重复2-4步骤，直到指针p为空且栈为空



**递归代码实现**

```cpp
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->val << endl;
    inorderTraversal(root->right);
}
```



**迭代代码实现**

```cpp
void inorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        TreeNode* p = root;
        while (!stk.empty() || p) {
            while (p) {
                stk.push(p);
                p = p->left;
            }
            if (!stk.empty()) {
                res.push_back(stk.top()->val);			// 遍历完左子树，再打印
                p = stk.top()->right;
                stk.pop();
            }
        }
}
```



#### 后序遍历

步骤



**递归代码实现**

```cpp
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->val << endl;
}
```



**迭代代码实现**

```cpp
void postorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        TreeNode* p = root;
        while (!stk.empty() || p) {
            while (p) {
                stk.push(p);
                p = p->left;
            }
            if (!stk.empty()) {
                res.push_back(stk.top()->val);
                p = stk.top()->right;
                stk.pop();
            }
        }
}
```







#### 层序遍历

**迭代步骤**

1. 初始化一个空队列，将根结点插入队尾

2. 每次从队列取出队头元素，同时将队头元素出队

3. 若存在左子结点则插入队尾，若存在右子结点则插入队头

4. 重复2、3步骤，直到队列为空





### 哈夫曼树

> 哈夫曼树也叫最有二叉树，用于对信息进行编码，原则是将出现率高的字母使用较短的编码，使得哈夫曼树是带权路径长度最小的树，从而减少了信息编码的长度，哈夫曼树算法是基于贪心的思想



#### 相关术语

* 路径： 树的结点到另一个结点之间的路径

* 路径长度：路径上边的数目

* 树的路径长度：根结点到每个结点的路径长度之和

  哈夫曼树将字符存在了每一个叶子结点，将每一个叶子结点值定义为权值，**哈夫曼树中权值越大，该结点说明出现的频率越高**

* 树的带权路径长度：树中全部叶子结点的带权路径长度之和，即$WPL = \sum_{k=1}^{n}{w_kl_k}$

相关计算

![](https://img2018.cnblogs.com/blog/1281523/201904/1281523-20190429151920686-1528959792.png)



#### 哈夫曼树算法步骤

1. 先统计所有字符出现的频率，分配权值
2. 从权值集中每次找最小的两个权值，权值小的左边，大的右边，两个结点权值之和作为根节点
3. 删除权值集中这个两个最小的权值，并加入该根节点的权值
4. 若权值集大于1，则重复第二步，等于1则哈夫曼树构造完成



从上述哈夫曼树构造过程中可以看出，**所有带有权值的字符一定都在叶子结点**， 由于都在叶子结点，避免了某一字符编码前缀包含了另一字符编码，造成编码的二义性。





[参考资料：哈夫曼树原理及其构造](https://blog.csdn.net/qq_29519041/article/details/81428934)



### 二叉搜索树



### AVL树



### 红黑树



### B树/B+树



### 伸展树、主席树...





### 相关习题(有亿点点多...)

| 题目链接                                                     | 说明             |
| ------------------------------------------------------------ | ---------------- |
| [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) | 前序遍历模板     |
| [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) | 前序遍历拓展     |
| [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 中序遍历模板     |
| [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) | 后序遍历模板     |
| [590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) | 后序遍历拓展     |
| [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) | 层序遍历模板     |
| [107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) | 层序遍历模板变形 |
| [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) | 层序遍历拓展     |
| [429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) | 层序遍历拓展     |
| [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) | 层序遍历拓展     |
| [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/) | 层序遍历拓展     |
| [100. 相同的树](https://leetcode-cn.com/problems/same-tree/) |                  |
| [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) |                  |
| [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) |                  |
| [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) |                  |
| [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) |                  |
| [559. N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) |                  |
| [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/) |                  |
| [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/) |                  |
| [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/) |                  |
| [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/) |                  |
| [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/) |                  |
| [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)  |                  |
| [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) |                  |
| [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/) |                  |
| [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) |                  |
| [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/) |                  |
| [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) |                  |
| [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) |                  |
| [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) |                  |
| [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/) |                  |
| [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) |                  |
| [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) |                  |
| [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/) |                  |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) |                  |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) |                  |





### 堆

> 堆(heap)经常用于实现优先队列(priority queue)即每次从队列取出来的都是优先级最高的元素
>
> 堆的特点有以下几点
>
> * 堆是一个完全二叉树
> * 堆的两个子树也满足堆的性质
> * 大根堆根上为最大元素，小根堆根上为最小元素
>
> 堆一般采用静态数组来实现





## 并查集

### 作用

1. 将两个集合合并
2. 判断元素属于哪个集合





### 并查集的相关操作

1. 初始化数组（代表每个结点的父节点）将每一个结点的父节点设置为自己表示为根节点，即p[i] = i
2. 查找元素所属的集合（find），则不断利用数组p寻找父结点直到p[i] = i，即while (p[i] != i) find(p[i])
3. 合并两个集合操作（union），找到两个集合的根结点，将一个结点的父节点设置成另一个结点





### 并查集优化

1. 按秩归并：基本思路是将较少结点的根节点指向包含较多的根节点

   

2. 路径压缩：在进行find操作时同时将所有子结点的根节点设置为该集合的根节点，减少了子结点到根节点的距离



### 并查集模板

```cpp
// 初始化
for (int i = 1; i <= n; i++) p[i] = i;

// find(x) 表示查找结点x所在集合的根结点
int find(int x) {
    if (x == p[x]) return x;
    p[x] = find(p[x]);
}

// 将集合a合并到集合b
p[find(a)] = find(b)
```





### 相关习题

| 题目链接                                                     | 说明                                   |
| ------------------------------------------------------------ | -------------------------------------- |
| [836. 合并集合](https://www.acwing.com/problem/content/838/) | 并查集模板                             |
| [837. 连通块中点的数量](https://www.acwing.com/problem/content/839/) | 维护连通块点的数量                     |
| [237. 程序自动分析](https://www.acwing.com/problem/content/239/) | 维护相等的集合                         |
| [238. 银河英雄传说](https://www.acwing.com/problem/content/240/) | 维护结点到根节点的距离和集合的大小     |
| [239. 奇偶游戏](https://www.acwing.com/problem/content/241/) | 用异或来维护前缀和之间的关系           |
| [240. 食物链](https://www.acwing.com/problem/content/242/)   | 维护结点到根节点的距离                 |
| [1250. 格子游戏](https://www.acwing.com/problem/content/1252/) | 封闭的圈等价于要连接的两个点在同一集合 |



## 字符串与字典树

### 字符串



### Trie





## 哈希表

## 递推、位运算、快速幂

## 递归和回溯

## 简单的DFS与BFS

## DFS与剪枝

## 建图方式与最短路

## 拓扑排序与最短路应用

## 动态规划

### 线性DP

### 背包

### 区间DP

### 树形DP

### 状态压缩DP

### 状态机模型

### 其它





## 树状数组与线段树





## 贪心







## 数论









## 博弈论

