## 算法与数据结构总结

> 常用算法以及思想包括了**二分、前缀和、差分、枚举、递归递推、动态规划、双指针、排序、贪心、图论相关的包括DFS、BFS、最短路**、二分图、最小生成树等、数论相关的有**辗转相除法、拓展欧几里得、线性筛素数**等、还有一些博弈论的相关结论、相关字符串算法
>
> 数据结构包括了：数组**链表**、**队列、栈、堆**的概念和应用（包括了**单调队列**、**单调栈**）、哈希表的应用、树包括了**二叉搜索树**，**Trie**，还有一些复杂的（B树、B+树、平衡树、红黑树这些了解即可），图的数据结构（基于邻接矩阵、邻接表、前向星的**建图**方法）、**并查集**、树状数组与线段树简单应用
>
> 除此之外我们还可以利用相关技巧如**位运算**写出更优美代码
>
> 本篇用于总结以上算法与数据结构以及相关技巧，再结合其应用来更好地理解与巩固基础



## 常用算法

### 算法

> 定义：给出确定和完整地指令，再给定一组输出，算法能够在有限地时间获得输出结果

#### 性质

* 有限性
* 确定性
* 有输入输出
* 有效性

#### 常用的算法思想

递推、递归、枚举、贪心、分治、迭代、回溯



#### 时间复杂度和空间复杂度



![](http://static.oschina.net/uploads/space/2014/0426/210036_kKPH_1246663.png)



#### 时间复杂度反推算法

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95.png?raw=true)



### 二分

> 二分查找是一种高效率地查找，经典应用是在有序排列的数组找到目标值
>
> 二分查找的本质是找到某种性质，能将顺序表划分了两段，其中一段符合该性质，另一段不符合性质，即具有二段性



整数二分模板

```c++
// 查找区间右端点
int low = 0, high = n - 1;
while (low < high) {
    int mid = low + high + 1 >> 1;
    if (nums[mid] <= target) {				
        ll = mid;
    } else {
        rr = mid - 1;
    }
}


// 查找区间左端点
while (low < high) {
    int mid = low + high >> 1;
    if (nums[mid] >= target) {				
        rr = mid;
    } else {
        ll = mid + 1;
    }
}
```



浮点数二分模板

```c++
while (high - low > 1e-6) {							// 终止的条件为精度
    double mid = (low + high) / 2;					// 由于是浮点数，不能用右移的方式
    if (num[mid] >= target) {
        rr = mid;
    } else {
        ll = mid;
    }
}
```



#### 相关题型

- leetcode

| 题目链接                                                     | 二分依据                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [704.二分查找](https://leetcode-cn.com/problems/binary-search/) | 有序数组，寻找区间端点                                       |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | 有序数组，第一个位置即第一个大于等于目标值(区间向左缩)，最后一个位置即最后一个小于等于目标值(区间向右缩) |
| [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/) | 某点下标与值相同，缺失的数字则一定在右区间，反之则一定在左区间（区间向左缩） |
| [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)    | 由于只保留整数部分，可以看作需要查找最大的mid满足x >= mid^2（区间向右缩） |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) | 目标值不存在数组则按顺序插入，即寻找最后一个小于等于目标值的位置（区间向右缩） |
| [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/) | 三分可解决，用二分则通过mid与mid + 1比较                     |
| [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/) | nums[mid] > nums[mid + 1],mid左区间(包含mid)必定存在峰值，区间向左缩 |
| [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/) | 二分套二分，先用二分寻找峰值，峰值左右两边再二分找目标值     |
| [1237. 找出给定方程的正整数解](https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/) | 枚举变量x，由于f(x,y)为严格单调，因此可以对y进行二分，使得f(x, y) - z == 0 |
| [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/) | 寻找第一个出错的版本，区间向左缩，需要考虑mid计算溢出        |
| [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) | min{前一部分数组} > max{后一部分数组}因此下标为mid的值与右区间端点比较，具有二段性，小于右区间端点，最小值在mid左边，区间向左缩 |
| [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，右指针向左移动一位排除相同的值 |
| [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) | 分析可得min{前一部分数组} > max{后一部分数组}，二分找到旋转点，选择一个区间进行二分 |
| [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，需要特判从结尾排除与nums[0]相同的值 |
| [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/) | 枚举运载能力x，若d天内x能完成，则大于等于x的运载能力都能完成，即具有二段性 |
| [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182) | 枚举最大值，每个段子数组的和不应该超过最大值，若无法找到这样的情况则最大值不能再枚举更小的数，即具有二段性 |

- Acwing



| 题目链接                                                     |      |
| ------------------------------------------------------------ | ---- |
| [1221. 四平方和](https://www.acwing.com/problem/content/1223/) |      |
| [1227. 分巧克力](https://www.acwing.com/problem/content/1229/) |      |
| [730. 机器人跳跃问题](https://www.acwing.com/problem/content/732/) |      |



### 前缀和、差分

> 前缀和运用了递推的思想，经典的空间复杂度换时间时间复杂度的策略



#### 前缀和

| 题目链接                                                     | 思路 |
| ------------------------------------------------------------ | ---- |
| [1236. 递增三元组](https://www.acwing.com/problem/content/1238/) |      |
| [1230. K倍区间](https://www.acwing.com/problem/content/1232/) |      |
| [102. 最佳牛围栏](https://www.acwing.com/problem/content/104/) |      |
| [99. 激光炸弹](https://www.acwing.com/problem/content/101/)  |      |



#### 差分

| 题目链接                                                     |      |
| ------------------------------------------------------------ | ---- |
| [797.差分](https://www.acwing.com/problem/content/799/)      |      |
| [101. 最高的牛](https://www.acwing.com/problem/content/103/) |      |





### 双指针和排序

#### 双指针

> 双指针的一般

#### 常用排序算法

**参考资料**：[十大经典排序](https://www.cnblogs.com/onepixel/articles/7674659.html)



#### 0. 十大排序算法比较

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

#### 1. 插入排序



1. 算法思路
   * 从未排序中的数组选择一个元素e插入到已排序好的数组中
   * 按倒序顺序遍历已排序好的数组（遍历的值设为x）逐个与e进行比较
   * 若x大于元素e，则将将x向后移动一位，若x小于等于则将e插入该位置
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```c++
void insert(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        int j = i, e = arr[i];
        while (j > l && arr[j - 1] > e) arr[j] = arr[j - 1], j--;
        arr[j] = e;
    }
}
```



#### 2. 选择排序

1. 算法思路

   * 每次从未排序的数组中选择一个最小的元素e
   * 将元素e插入到已排序数组的末尾
   * 重复上述步骤，直到所有元素都已排序

2.  代码实现

   ```c++
   void select(int l, int r, int arr[]) {
       for (int i = l; i <= r; i++) {
           int inx = i;
           for (int j = i; j <= r; j++) {
               if (arr[j] < arr[inx]) inx = j;
           }
           swap(arr[inx], arr[i]);
       }
   }
   ```



#### 3. 希尔排序

> 简单插入排序的改良版本,又称缩小增量排序，实质是分组的插入排序
>
> * 希尔排序的时间复杂度和增量序列是相关的



```cpp
void shell(int l, int r, int arr[]) {
    int len = r - l + 1;
    for (int i = len >> 1; i > 0; i >>= 1) {
        for (int j = i; j <= r; j++) {
            int k = j, e = arr[k];
            while (k >= i && arr[k - i] > e) arr[k] = arr[k - i], k -= i;
            arr[k] = e;
        }
    }
}
```







#### 4. 冒泡排序

1. 算法思路 

   * 每次从头开始相邻两个元素比较
   * 若前一个元素大于后一个元素则交换
   * 到数组结尾则完成这一轮的操作
   * 若某一轮次未有交换发生则说明该数组已排好序，提前退出
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```cpp
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);
        }
    }
}



// 优化的代码
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        bool flag = true;
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag = false;
                swap(arr[j], arr[j + 1]);
            }
        }
        if (flag) break;
    }
}
```





#### 5. 快速排序

1. 算法思路

   * 确定一个基准值pivot
   * 小于等于pivot的值放在数组前半部分，大于等于pivot的值放在数组后半部分
   * 分别对数组前半部分和后半部分递归，直到区间长度为1

2. 代码实现

```cpp
void quick(int l, int r, int arr[]) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = arr[i + j >> 1];
    
    while (i < j) {
        do i++; while (arr[i] < x);
        do j--; while (arr[j] > x);
        if (i < j) swap(arr[i], arr[j]);
    }

    quick(l, j, arr), quick(j + 1, r, arr);
}
```







#### 6. 归并排序

> 归并排序是稳定的排序，时间复杂度也是稳定的，其代价是需要额外的内存空间

1. 算法思路

   * 将区间一分为二，对两个区间进行递归，直到区间大小为1，自顶向下
   * 对这两个区间进行归并（这两个区间都是有序的），放在另一个数组中

   * 再将另一个数组复制到原数组

2. 代码实现

```cpp
void merge(int l, int r, int arr[]) {
    if (l >= r) return;
    int mid = l + r >> 1, i = l, j = mid + 1, k = 0;
    merge(l, mid, arr), merge(mid + 1, r, arr);
    
    while (i <= mid && j <= r) {
        if (arr[i] > arr[j]) cop[k++] = arr[j++];
        else cop[k++] = arr[i++];
    }
    
    while (i <= mid) cop[k++] = arr[i++];
    while (j <= r) cop[k++] = arr[j++];
    
    for (int i = l, k = 0; i <= r; i++, k++) arr[i] = cop[k];
}
```





#### 7. 堆排序

> 借助堆的数据结构







### 高精度

> 包含了高精度的大整数加减乘除运算

* A：高精度数字如何存储？

  Q：数组低地址存低位

高精度加法

```cpp
vector<int> add(vector<int>& a, vector<int>& b) {
    int res = 0;
    vector<int> c;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) res += a[i];
        if (i < b.size()) res += b[i];
        c.push_back(res % 10);
        res /= 10;
    }
    if (res) c.push_back(res);
    return c;
}
```



高精度减法

```c++
// 需要保证a >= b,且a、b均为非负数
vector<int> sub(vector<int>& a, vector<int>& b) {
    vector<int> c;
    int res = 0;
    for (int i = 0; i < a.size(); i++) {
        res = a[i] - res;
        if (i < b.size()) res -= b[i];
        c.push_back((res + 10) % 10);
        if (res < 0) res = 1;
        else res = 0;
    }
    // 去除前导0
    while (c.size() > 1 && c[c.size() - 1] == 0) c.pop_back();
    return c;
}
```



高精度乘法



高精度除法



### 数组与链表





### 队列与栈

#### 队列模板

* 队列具有FIFO(First In First Out)特点

```cpp
// 普通队列, tt表示队尾指针，hh表示队头指针
int queue[N], tt = -1, hh = 0;

// 队尾入队
queue[++tt] = e;

// 是否为空
若hh > tt 则说明队列为空
    
// 队头出队
hh++
    
// 查询队头元素
queue[hh]
    
// 查询大小
tt - hh + 1
```



#### 栈模板

* 堆栈具有FILO(First In Last Out)特点

```cpp
// 普通堆栈，hh表示栈顶指针
int stack[N], hh = 0;

// 判断是否为空
hh等于0则为空
    
// 入栈
stack[++hh] = e;

// 出栈
--hh;

// 查询栈顶元素
stack[hh]
    
// 查询大小
hh
```



#### 单调栈

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int hh = 0;
for (int i = 1; i <= n; i ++ )
{
    while (hh && check(stk[hh], i)) tt -- ;
    stk[ ++ hh] = i;
}
```



#### 单调队列





#### 相关习题



| 题目链接                                                     |                                                |
| ------------------------------------------------------------ | ---------------------------------------------- |
| [829. 模拟队列](https://www.acwing.com/problem/content/description/831/) | 模板                                           |
| [828. 模拟栈](https://www.acwing.com/problem/content/description/830/) | 模板                                           |
| [830. 单调栈](https://www.acwing.com/problem/content/832/)   | 利用单调栈，找到每个数离它左边最近的比它小的数 |
|                                                              |                                                |







### 堆与字典树





### 并查集





### 字符串与哈希表



### 树的存储与遍历





### 递推、位运算、快速幂





### 回溯和递归





### 简单DFS与BFS



### DFS与剪枝





### 建图方式与最短路





### 拓扑排序与最短路应用





### 动态规划

#### 线性DP

#### 背包

#### 区间DP

#### 树形DP

#### 状态压缩DP

#### 状态机模型

#### 其它





### 树状数组与线段树







### 贪心





### 数论





### 博弈论





