# 算法与数据结构总结

> 常用算法以及思想包括了**二分、前缀和、差分、枚举、递归递推、动态规划、双指针、排序、贪心、图论相关的包括DFS、BFS、最短路**、二分图、最小生成树等、数论相关的有**辗转相除法、拓展欧几里得、线性筛素数**等、还有一些博弈论的相关结论、相关字符串算法
>
> 数据结构包括了：数组**链表**、**队列、栈、堆**的概念和应用（包括了**单调队列**、**单调栈**）、哈希表的应用、树包括了**二叉搜索树**，**Trie**，还有一些复杂的（B树、B+树、平衡树、红黑树这些了解即可），图的数据结构（基于邻接矩阵、邻接表、前向星的**建图**方法）、**并查集**、树状数组与线段树简单应用
>
> 我们还可以利用相关技巧如**位运算**、**哨兵**写出更简洁的代码
>
> 本篇用于总结以上算法与数据结构以及相关技巧，再结合其应用来更好地理解与巩固基础



## 算法概述

### 算法

> 定义：给出确定和完整地指令，再给定一组输出，算法能够在有限地时间获得输出结果

#### 性质

* 有限性
* 确定性
* 有输入输出
* 有效性

#### 常用的算法思想

递推、递归、枚举、贪心、分治、迭代、回溯



#### 时间复杂度和空间复杂度

* 复杂度一般用O表示法，表示一个函数运行的渐进上界

![](http://static.oschina.net/uploads/space/2014/0426/210036_kKPH_1246663.png)



#### 时间复杂度反推算法

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95.png?raw=true)

## 数据结构概述

### 数据结构

> 定义：计算机中存储与组织特定关系的数据元素的方式

#### 逻辑结构

> 反映数据之间的逻辑关系

1. 线性结构：元素之间一对一的关系，
2. 树形结构：元素之间一对多或者多对一的关系
3. 图形结构：元素之间多对多的关系

#### 物理结构

1. 顺序存储：元素在内存中按顺序存放，可随机存取元素，插入或删除需要移动元素
2. 链接存储：由数据域与指针域构成，逻辑上相邻而物理上不必相邻，插入、删除灵活
3. 索引存储：除了存储结点信息外，还需要建立附加的索引表来表示结点的地址，索引表由若干个索引项组成
4. 散列存储：由键值对组成，通过关键字来存取值







## 二分

> 二分查找是一种高效率地查找，经典应用是在有序排列的数组找到目标值
>
> 二分查找的本质是找到某种性质，能将顺序表划分了两段，其中一段符合该性质，另一段不符合性质，即具有二段性



* 用于顺序表的查找

* 查找的时间复杂度为$O(log_2N)$,其中N为数据规模



### 模板

整数二分模板

```c++
// 查找区间右端点
int low = 0, high = n - 1;
while (low < high) {
    int mid = low + high + 1 >> 1;
    if (nums[mid] <= target) {				
        ll = mid;
    } else {
        rr = mid - 1;
    }
}


// 查找区间左端点
while (low < high) {
    int mid = low + high >> 1;
    if (nums[mid] >= target) {				
        rr = mid;
    } else {
        ll = mid + 1;
    }
}
```



浮点数二分模板

```c++
while (high - low > 1e-6) {							// 终止的条件为精度
    double mid = (low + high) / 2;					// 由于是浮点数，不能用右移的方式
    if (num[mid] >= target) {
        rr = mid;
    } else {
        ll = mid;
    }
}
```



### 相关习题

| 题目链接                                                     | 二分依据                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [704.二分查找](https://leetcode-cn.com/problems/binary-search/) | 有序数组，寻找区间端点                                       |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | 有序数组，第一个位置即第一个大于等于目标值(区间向左缩)，最后一个位置即最后一个小于等于目标值(区间向右缩) |
| [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/) | 某点下标与值相同，缺失的数字则一定在右区间，反之则一定在左区间（区间向左缩） |
| [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)    | 由于只保留整数部分，可以看作需要查找最大的mid满足x >= mid^2（区间向右缩） |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) | 目标值不存在数组则按顺序插入，即寻找最后一个小于等于目标值的位置（区间向右缩） |
| [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/) | 三分可解决，用二分则通过mid与mid + 1比较                     |
| [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/) | nums[mid] > nums[mid + 1],mid左区间(包含mid)必定存在峰值，区间向左缩 |
| [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/) | 二分套二分，先用二分寻找峰值，峰值左右两边再二分找目标值     |
| [1237. 找出给定方程的正整数解](https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/) | 枚举变量x，由于f(x,y)为严格单调，因此可以对y进行二分，使得f(x, y) - z == 0 |
| [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/) | 寻找第一个出错的版本，区间向左缩，需要考虑mid计算溢出        |
| [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) | min{前一部分数组} > max{后一部分数组}因此下标为mid的值与右区间端点比较，具有二段性，小于右区间端点，最小值在mid左边，区间向左缩 |
| [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，右指针向左移动一位排除相同的值 |
| [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) | 分析可得min{前一部分数组} > max{后一部分数组}，二分找到旋转点，选择一个区间进行二分 |
| [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，需要特判从结尾排除与nums[0]相同的值 |
| [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/) | 枚举运载能力x，若d天内x能完成，则大于等于x的运载能力都能完成，即具有二段性 |
| [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182) | 枚举最大值，每个段子数组的和不应该超过最大值，若无法找到这样的情况则最大值不能再枚举更小的数，即具有二段性 |
| [1221. 四平方和](https://www.acwing.com/problem/content/1223/) | 预处理二元组，根据主键顺序排序，枚举前两个的平方和再根据二元组的大小进行二分 |
| [1227. 分巧克力](https://www.acwing.com/problem/content/1229/) | 对巧克力边长进行二分                                         |
| [730. 机器人跳跃问题](https://www.acwing.com/problem/content/732/) | 对初始能量进行二分                                           |



## 前缀和、差分

> 前缀和运用了递推的思想，经典的空间复杂度换时间时间复杂度的策略

### 前缀和

#### 一维前缀和

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png?raw=true)

设数组为$a[i],i > 0$,前缀和s数组表示为$s[i] = \sum^{i}_{j=1}a[j]$，则一维前缀和公式为$s[i] - s[j - 1] = \sum_{k=i}^{j}a[k],其中s[0]定义为0$

#### 二维前缀和

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C1.png?raw=true)

* 与一维前缀和类似的，值从下标为1开始存储，并定义$a[i][j] = 0，i = 0 || j = 0$

![image-20200806201419354](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C2.png?raw=true)

* 倘若要计算红色部分+蓝色部分+橙色部分+黑色部分即$S_{3,3}$，那么先计算出红色部分+橙色部分即$S_{2,3}$，再计算出红色部分+蓝色部分即$S_{3,2}$
* 由**容斥定理**可知，我们需要再**减去一个红色部分**，$S_{3,3} = S_{2,3} + S_{3,2} - S_{2,2} + a[i][j]$ 



![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C3.png?raw=true)



类似的利用上述方法，我们可以计算出子矩阵的前缀和

* 红色矩阵是需要求的子矩阵和，蓝色部分左上角即原矩阵的左上角，右下角为红色矩阵的右下角
* 由**容斥定理**得，红色部分 = 蓝色部分 - 粉色部分 - 橙色部分 + 粉色部分与橙色部分重叠部分



**二维前缀和公式**

* 对数组a进行处理，得到前缀和矩阵$s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1]$   i,j均为正整数

* 对任意子矩阵，左上角为$(i,j)$,右下角为$(x,y)$有如下公式
  $$
  S_{(i,j), (x,y)} = S_{(0,0), (x,y)} - S_{(0,0), (x - 1,y)} - S_{(0,0), (x,y - 1)} + S_{(0,0), (i - 1,j - 1)}
  $$
  其中$S_{(0,0),(x,y)}$即为前缀和矩阵$s[x][y]$ 

### 差分

#### 一维差分

```cpp
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```



#### 二维差分

```cpp
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```





### 相关习题

| 题目链接                                                     | 思路                                   |
| ------------------------------------------------------------ | -------------------------------------- |
| [1236. 递增三元组](https://www.acwing.com/problem/content/1238/) | 利用前缀和统计大于等于和小于等于bi的数 |
| [1230. K倍区间](https://www.acwing.com/problem/content/1232/) | 抓住s[i] % k = s[j] % k条件            |
| [102. 最佳牛围栏](https://www.acwing.com/problem/content/104/) | 前缀和+二分的应用                      |
| [796. 子矩阵的和](https://www.acwing.com/problem/content/798/) | 二维前缀和模板                         |
| [99. 激光炸弹](https://www.acwing.com/problem/content/101/)  | 二维前缀和应用                         |
| [797.差分](https://www.acwing.com/problem/content/799/)      | 模板题                                 |
| [798. 差分矩阵](https://www.acwing.com/problem/content/800/) | 二维差分矩阵模板                       |
| [101. 最高的牛](https://www.acwing.com/problem/content/103/) | 差分应用                               |





## 双指针和排序

### 双指针



> 双指针的思想应用范围很广





### 排序



#### 0. 十大排序算法比较

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

#### 1. 插入排序



1. 算法思路
   * 从未排序中的数组选择一个元素e插入到已排序好的数组中
   * 按倒序顺序遍历已排序好的数组（遍历的值设为x）逐个与e进行比较
   * 若x大于元素e，则将将x向后移动一位，若x小于等于则将e插入该位置
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```c++
void insert(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        int j = i, e = arr[i];
        while (j > l && arr[j - 1] > e) arr[j] = arr[j - 1], j--;
        arr[j] = e;
    }
}
```



#### 2. 选择排序

1. 算法思路

   * 每次从未排序的数组中选择一个最小的元素e
   * 将元素e插入到已排序数组的末尾
   * 重复上述步骤，直到所有元素都已排序

2.  代码实现

   ```c++
   void select(int l, int r, int arr[]) {
       for (int i = l; i <= r; i++) {
           int inx = i;
           for (int j = i; j <= r; j++) {
               if (arr[j] < arr[inx]) inx = j;
           }
           swap(arr[inx], arr[i]);
       }
   }
   ```



#### 3. 希尔排序

> 简单插入排序的改良版本,又称缩小增量排序，实质是分组的插入排序
>
> * 希尔排序的时间复杂度和增量序列是相关的



```cpp
void shell(int l, int r, int arr[]) {
    int len = r - l + 1;
    for (int i = len >> 1; i > 0; i >>= 1) {
        for (int j = i; j <= r; j++) {
            int k = j, e = arr[k];
            while (k >= i && arr[k - i] > e) arr[k] = arr[k - i], k -= i;
            arr[k] = e;
        }
    }
}
```







#### 4. 冒泡排序

1. 算法思路 

   * 每次从头开始相邻两个元素比较
   * 若前一个元素大于后一个元素则交换
   * 到数组结尾则完成这一轮的操作
   * 若某一轮次未有交换发生则说明该数组已排好序，提前退出
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```cpp
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);
        }
    }
}



// 优化的代码
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        bool flag = true;
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag = false;
                swap(arr[j], arr[j + 1]);
            }
        }
        if (flag) break;
    }
}
```





#### 5. 快速排序

1. 算法思路

   * 确定一个基准值pivot
   * 小于等于pivot的值放在数组前半部分，大于等于pivot的值放在数组后半部分
   * 分别对数组前半部分和后半部分递归，直到区间长度为1

2. 代码实现

```cpp
void quick(int l, int r, int arr[]) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = arr[i + j >> 1];
    
    while (i < j) {
        do i++; while (arr[i] < x);
        do j--; while (arr[j] > x);
        if (i < j) swap(arr[i], arr[j]);
    }

    quick(l, j, arr), quick(j + 1, r, arr);
}
```







#### 6. 归并排序

> 归并排序是稳定的排序，时间复杂度也是稳定的，其代价是需要额外的内存空间

![](https://camo.githubusercontent.com/ce0f02cdc800ad02551271b79ecc6a778280a41b/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f313032343535352f3230313631322f313032343535352d32303136313231383136333132303135312d3435323238333735302e706e67)

1. 算法思路

   * 将区间一分为二，对两个区间进行递归，直到区间大小为1，自顶向下
   * 对这两个区间进行归并（这两个区间都是有序的），放在另一个数组中

   * 再将另一个数组复制到原数组

2. 代码实现

```cpp
void merge(int l, int r, int arr[]) {
    if (l >= r) return;
    int mid = l + r >> 1, i = l, j = mid + 1, k = 0;
    merge(l, mid, arr), merge(mid + 1, r, arr);
    
    while (i <= mid && j <= r) {
        if (arr[i] > arr[j]) cop[k++] = arr[j++];
        else cop[k++] = arr[i++];
    }
    
    while (i <= mid) cop[k++] = arr[i++];
    while (j <= r) cop[k++] = arr[j++];
    
    for (int i = l, k = 0; i <= r; i++, k++) arr[i] = cop[k];
}
```





#### 7. 堆排序

> 借助堆的数据结构

1. 算法思路

   * 建堆
   * 打印当前位于堆的最大值或最小值
   * 将堆最后一个编号的值移动到堆顶
   * 维护堆的性质

2. 代码实现

```cpp
void down(int u) {
    int t = u;
    if (2 * u <= n && h[t] > h[2 * u]) t = 2 * u;
    if (2 * u + 1 <= n && h[t] > h[2 * u + 1]) t = 2 * u + 1;
    if (t != u) {
        swap(h[t], h[u]);
        down(t);
    }
}

// 建堆
for (int i = n / 2; i >= 0; i--) down(i);
// 输出结果
for (int i = 1; i <= m; i++) {
    cout << h[1] << ' ';
    h[1] = h[n--];
    down(1);
}
```











**参考资料**：[十大经典排序](https://www.cnblogs.com/onepixel/articles/7674659.html)





## 高精度与离散化



### 高精度

> 包含了高精度的大整数加减乘除运算

* A：高精度数字如何存储？

  Q：数组低地址存低位

#### 高精度加法



```cpp
vector<int> add(vector<int>& a, vector<int>& b) {
    int res = 0;
    vector<int> c;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) res += a[i];
        if (i < b.size()) res += b[i];
        c.push_back(res % 10);
        res /= 10;
    }
    if (res) c.push_back(res);
    return c;
}
```



#### 高精度减法

```c++
// 需要保证a >= b,且a、b均为非负数
vector<int> sub(vector<int>& a, vector<int>& b) {
    vector<int> c;
    int res = 0;
    for (int i = 0; i < a.size(); i++) {
        res = a[i] - res;
        if (i < b.size()) res -= b[i];
        c.push_back((res + 10) % 10);
        if (res < 0) res = 1;
        else res = 0;
    }
    // 去除前导0
    while (c.size() > 1 && c[c.size() - 1] == 0) c.pop_back();
    return c;
}
```



#### 高精度乘法

```cpp
// a*b, b为低精度
vector<int> mul(vector<int>& a, int b) {
    int t = 0;
    vector<int> res;
    for (int i = 0; i < a.size(); i++) {
        t += b * a[i];
        res.push_back(t % 10);
        t /= 10;
    }
    
    while (t) {
        res.push_back(t % 10);
        t /= 10;
    }
    // 去除前导0
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}

// a*b, a、b均为高精度
vector<int> mul(vector<int>& a, vector<int>& b) {
    int t = 0;
    vector<int> res(a.size() + b.size(), 0);
    for (int i = 0; i < a.size(); i++) {
        for (int j = 0; j < b.size(); j++) {
            res[i + j] += a[i] * b[j];
        }
    }
    
    for (int i = 0; i < res.size(); i++) {
        t += res[i];
        res[i] = t % 10;
        t /= 10;
    }
    // 去除前导0
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}
```



#### 高精度除法

```cpp
// b为低精度, t为余数
vector<int> div(vector<int>& a, int b) {
    vector<int> res;
    // 模拟除法，从高位开始除
    for (int i = a.size() - 1; i >= 0; i--) {
        t = t * 10 + a[i];
        res.push_back(t / b);
        t %= b;
    }
    
    reverse(res.begin(), res.end());
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}

```





### 离散化

> 离散化的本质是映射。离散化的意义是将区间范围很大，而用到的值的个数少，且需要保持其值相对大小的集合进行映射



```cpp
// 离散化前的准备
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) { // 找到第一个大于等于x的位置
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}


// 哈希表映射
unordered_map<int, int> ma				// 采用unordered_map进行映射
for (auto i : all) ma[i] = ++cnt;       // 映射到1, 2, ...n
```





## 链表

>物理存储不连续，而逻辑上连续，相比于数组来说，删除和插入效率高，但是查找的效率比数组慢

### 常用技巧

* 头结点的使用，在单链表的第一个结点之前设置有一个结点，也称为哑结点，能简化代码逻辑
* 双指针算法：在链表中双指针一般指快慢指针



### 单链表

结构：由数据域和直接后驱指针域构成



### 双链表

结构：由数据域和直接前驱、直接后驱指针域构成



### 静态链表

> 常用于存图操作，解决了邻接表的链表结构实现慢，邻接矩阵开辟浪费空间的问题，静态链表也叫做前向星



#### 模板

```cpp
// inx表示插入的第inx个结点，h表示头结点，e[inx]表示第inx个结点存储的值，ne[inx]表示第inx个结点的下一个结点
int inx, h, e[N], ne[N];
// 初始化
h = -1, inx = 0;

// 插入头结点(链表不为空)
e[inx] = element, ne[inx] = ne[h], h = inx++;

// 删除第k个头结点
// k = 0，删除头结点
h = ne[h];
// k不为0
ne[k - 1] = ne[ne[k - 1]];

// 将结点插入到第k个结点
e[inx] = element, ne[inx] = ne[k - 1], ne[k - 1] = inx++;
```







### 相关习题

| 题目链接                                                     | 说明   |
| ------------------------------------------------------------ | ------ |
| [826. 单链表](https://www.acwing.com/problem/content/828/)   | 模板题 |
| [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/) |        |
| [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/) |        |
| [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) |        |
| [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/) |        |
| [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) |        |
| [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/) |        |
| [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/) |        |
| [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/) |        |
| [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) |        |
| [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) |        |
| [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/) |        |
| [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) |        |
| [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/) |        |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) |        |
| [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) |        |
| [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/) |        |
| [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/) |        |
| [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/) |        |
| [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/) |        |
| [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/) |        |
| [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) |        |
| [148. 排序链表](https://leetcode-cn.com/problems/sort-list/) |        |
| [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/) |        |
| [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) |        |
| [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/) |        |
| [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/) |        |
| [817. 链表组件](https://leetcode-cn.com/problems/linked-list-components/) |        |
| [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/) |        |
| [1019. 链表中的下一个更大节点](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/) |        |
| [1171. 从链表中删去总和值为零的连续节点](https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/) |        |
| [1290. 二进制链表转整数](https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/) |        |
| [1367. 二叉树中的列表](https://leetcode-cn.com/problems/linked-list-in-binary-tree/) |        |
| [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/) |        |
| [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/) |        |







## 队列与栈

### 模板

#### 普通队列模板

* 队列具有FIFO(First In First Out)特点

```cpp
// 普通队列, tt表示队尾指针，hh表示队头指针
int queue[N], tt = -1, hh = 0;

// 队尾入队
queue[++tt] = e;

// 是否为空
若hh > tt 则说明队列为空
    
// 队头出队
hh++
    
// 查询队头元素
queue[hh]
    
// 查询队尾元素
queue[tt]
```



#### 栈模板

* 堆栈具有FILO(First In Last Out)特点

```cpp
// 普通堆栈，hh表示栈顶指针
int stack[N], hh = 0;

// 判断是否为空
hh等于0则为空
    
// 入栈
stack[++hh] = e;

// 出栈
--hh;

// 查询栈顶元素
stack[hh]
    
// 查询大小
hh
```



#### 单调栈模板

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int hh = 0, a[N];
for (int i = 1; i <= n; i ++ ) {
    while (hh && check(stk[hh], i)) hh--;
    a[i] = stk[hh];
    stk[ ++ hh] = i;
}

常见模型：找出每个数右边离它最近的比它大/小的数
for (int i = n; i > 0; i -- ) {
    while (hh && check(stk[hh], i)) hh--;
    a[i] = skt[hh];
    stk[ ++ hh] = i;
}

// 由于是逆序查找，所以需要翻转一下数组
reverse(a, a + n);
```



#### 单调队列模板

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ ) {
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], a[i])) tt -- ;
    q[ ++ tt] = i;
}
```





### STL常用方法

```cpp
// queue普通队列
    size()
    empty() 
    push()  //向队尾插入一个元素
    front() //返回队头元素
    pop()   //弹出队头元素
    back()  //返回队尾元素

// stack栈
    size()
    empty()
    push()  //向栈顶插入一个元素
    top()   //返回栈顶元素
    pop()   //弹出栈顶元素
```



### 相关习题

| 题目链接                                                     | 说明                                           |
| ------------------------------------------------------------ | ---------------------------------------------- |
| [828. 模拟栈](https://www.acwing.com/problem/content/description/830/) | 模板                                           |
| [830. 单调栈](https://www.acwing.com/problem/content/832/)   | 利用单调栈，找到每个数离它左边最近的比它小的数 |
| [829. 模拟队列](https://www.acwing.com/problem/content/description/831/) | 模板                                           |
| [154. 滑动窗口](https://www.acwing.com/problem/content/description/156/) | 利用单调队列，在O(1)时间复杂度内找到区间的最值 |
| [651. 逛画展](https://www.acwing.com/problem/content/653/)   | 单调队列练习题                                 |
| [652. 切蛋糕](https://www.acwing.com/problem/content/654/)   | 单调队列练习题                                 |
| [135. 最大子序和](https://www.acwing.com/problem/content/description/137/) | 前缀和+单调队列                                |
| [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) | 下一题简化版                                   |
| [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/) | 两个栈来实现队列                               |
| [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/) | 两个队列来实现栈                               |
| [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) | 利用栈验证                                     |
| [150. 括号画家](https://www.acwing.com/problem/content/152/) | 求最长连续有效括号                             |
| [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/) | 栈的应用+字符串                                |
| [41. 包含min函数的栈](https://www.acwing.com/problem/content/90/) | 利用单调栈来维护最小值                         |
| [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/) | 模拟                                           |
| [129. 火车进栈](https://www.acwing.com/problem/content/131/) | dfs+模拟栈                                     |
| [131. 直方图中最大的矩形](https://www.acwing.com/problem/content/133/) | 单调栈的应用                                   |
| [152. 城市游戏](https://www.acwing.com/problem/content/154/) | 上题拓展                                       |
| [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) | 同上题思路                                     |
| [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) | 直方图最大矩形类型的题                         |
| [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/) | 查找右边最值问题                               |
| [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/) | 上题拓展                                       |
| [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) | 查找右边最值问题                               |
| [151. 表达式计算4](https://www.acwing.com/problem/content/153/) | 栈在表达式中的应用                             |
| [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) | 表达式计算简单版                               |
| [735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision/) | 栈的应用                                       |
| [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/) | 队列应用                                       |



## 树

### 树的定义及其术语

> 定义：除了根结点以外，每个结点有且仅有一个父结点，都拥有多个孩子结点，每个结点及其该结点的孩子结点组成的结合其结构也符合树的定义



* 叶子结点：无孩子的结点

* 结点的度：指孩子节点的个数

### 二叉树

> 二叉树的定义： 二叉树**要么为空**，要么每个结点**最多**只含有**两个直接孩子结点**，这两个直接孩子结点及其它们的孩子结点也分别称为左右子树，该左右子树符合二叉树的定义



#### 二叉树的性质

* 性质1

  二叉树第i层最多有$2^{i-1}$ 个结点, $i>=1$

* 性质2

  深度为k的二叉树最多有$2^k-1$个结点

* 性质3

  定义度为i的结点为$n_i$ ，则二叉树满足${n_2} = {n_0} + 1$ 

  > 证明方法：
  >
  > 1. 首先树的总边数e与总结点数是满足于$e = n - 1$
  >
  > 上面的关系式可以理解成除了根节点以外，所有结点都对应一条与父结点的边，反过来，所有结点直接孩子的个数有关系式$n_1 + 2n_2 = e$
  >
  > 2. 总结点数有关系式$n = n_0 + n_1 + n_2$
  >
  > 3. $n_1 + 2n_2 + 1 = n_0 + n_1 + n_2$
  >
  >    即有${n_2} = {n_0} + 1$

  

* 性质4

  具有n个结点的完全二叉树的深度为$\lfloor log_2n \rfloor + 1$

* 性质5

  完全二叉树中的某结点为i，则

  1）若存在父结点，则父结点编号为$[i / 2]$

  2）若存在左子结点，则编号为$2i$

  3）若存在右子结点，则编号为$2i+1$

#### 完全二叉树与满二叉树



> 完全二叉树定义：按从上到下从左到右的顺序，从1开始，给二叉树每个结点依次编号，若结点数为n，则所有结点**在且仅在**编号1到编号n中

> 满二叉树的定义：深度为k的二叉树中，有且仅有$2^k - 1$个结点

![](https://bkimg.cdn.bcebos.com/pic/7acb0a46f21fbe0961cdc7e561600c338644adab?x-bce-process=image/crop,x_0,y_3,w_600,h_396/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

### 二叉树的存储

##### 物理存储结构

1. 数组存储（适合于完全二叉树）
2. 链表存储

##### 逻辑存储结构

* 双亲表示法

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923203304500-1066380837.png)

* 孩子表示法(**常用**)

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204350058-771438158.png)

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204035397-1294931058.png)



* 孩子兄弟表示法：

  ![img](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923212046972-354309866.png)



![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204256034-1713840703.png)







### 二叉树的遍历

树的结构体定义如下

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
```



#### 先序遍历

**递归版先序遍历步骤**

1. 遍历根结点

2. 遍历左子树

3. 遍历右子树

**迭代版先序遍历版本1步骤**

1. 初始化一个空栈，将指针p置为根结点
2. 若指针p不为空，则先打印该结点的值，再将指针p压入栈中
3. 指针p更新为p的左子结点，重复步骤2直到p为空
4. 若栈不为空，将指针p更新为栈顶结点的右子结点，弹出栈顶元素
5. 重复2-4步骤，直到指针p为空且栈为空



**递归代码实现**

```cpp
void preorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    cout << root->val << endl;
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}
```



**迭代代码实现**

```cpp
// 版本1
void preorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
    	vector<int> res;
        while (!stk.empty() || root) {
            while (root) {
                res.push_back(root->val);					// 先打印
                stk.push(root);
                root = root->left;
            }
            if (!stk.empty()) root = stk.top()->right, stk.pop();
        }
}

// 版本2
void preorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
    	vector<int> res;
    	if (root) stk.push(root);
        while (!stk.empty()) {
            root = stk.top(), stk.pop();
            res.push_back(root->val);
            if (root->right) stk.push(root->right);
            if (root->left) stk.push(root->left);
        }
}
```





#### 中序遍历

**递归版先序遍历步骤**

1. 遍历左子树

2. 遍历根结点

3. 遍历右子树

**迭代版中序遍历步骤**

1. 初始化一个空栈，将指针p置为根结点
2. 若指针p不为空，则将指针p压入栈中
3. 指针p更新为p的左子结点，重复步骤2直到p为空
4. 若栈不为空，打印栈顶结点的值，再将指针p更新为栈顶结点的右子结点，弹出栈顶元素
5. 重复2-4步骤，直到指针p为空且栈为空



**递归代码实现**

```cpp
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->val << endl;
    inorderTraversal(root->right);
}
```



**迭代代码实现**

```cpp
void inorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        while (!stk.empty() || root) {
            while (root) {
                stk.push(p);
                root = root->left;
            }
            res.push_back(stk.top()->val);			// 遍历完左子树，再打印
            root = stk.top()->right, stk.pop();
        }
}
```



#### 后序遍历

**递归版后序遍历步骤**

1. 遍历左子树
2. 遍历右子树
3. 遍历根结点

**迭代版后序遍历步骤**

类似与先序遍历的迭代实现，将访问顺序调整为根右左，最后将结果反转即为后序遍历





**递归代码实现**

```cpp
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->val << endl;
}
```



**迭代代码实现**

```cpp
// 版本1
void postorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
    	vector<int> res;
        while (!stk.empty() || root) {
            while (root) {
                res.push_back(stk.top()->val);
                stk.push(root);
                root = root->right;
            }
            root = stk.top()->left, stk.pop();
        }
    	reverse(res.begin(), res.end());
}

// 版本2
void postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if (root) stk.push(root);
        while (!stk.empty()) {
            root = stk.top(), stk.pop();
            res.push_back(root->val);
            if (root->left) stk.push(root->left);
            if (root->right) stk.push(root->right);
        }
        reverse(res.begin(), res.end());
        return res;
}
```







#### 层序遍历

**迭代步骤**

1. 初始化一个空队列，将根结点插入队尾
2. 每次从队列取出队头元素，同时将队头元素出队
3. 若存在左子结点则插入队尾，若存在右子结点则插入队头
4. 重复2、3步骤，直到队列为空



**代码实现**

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> q;
    vector<vector<int>> res;
    if (root) q.push(root);
    while (!q.empty()) {
        int sz = q.size();
        vector<int> tmp;
        for (int i = 0; i < sz; i++) {
            root = q.front();
            q.pop();
            tmp.push_back(root->val);
            if (root->left) q.push(root->left);
            if (root->right) q.push(root->right);
        }
        res.push_back(tmp);
    }
    return res;
}
```





### 哈夫曼树

> 哈夫曼树也叫最优二叉树，用于对信息进行编码，原则是将出现率高的字母使用较短的编码，使得哈夫曼树是带权路径长度最小的树，从而减少了信息编码的长度，哈夫曼树算法是基于贪心的思想



#### 相关术语

* 路径： 树的结点到另一个结点之间的路径

* 路径长度：路径上边的数目

* 树的路径长度：根结点到每个结点的路径长度之和

  哈夫曼树将字符存在了每一个叶子结点，将每一个叶子结点值定义为权值，**哈夫曼树中权值越大，该结点说明出现的频率越高**

* 树的带权路径长度：树中全部叶子结点的带权路径长度之和，即$WPL = \sum_{k=1}^{n}{w_kl_k}$

相关计算

![](https://img2018.cnblogs.com/blog/1281523/201904/1281523-20190429151920686-1528959792.png)



#### 哈夫曼树算法步骤

1. 先统计所有字符出现的频率，分配权值
2. 从权值集中每次找最小的两个权值，权值小的左边，大的右边，两个结点权值之和作为根节点
3. 删除权值集中这个两个最小的权值，并加入该根节点的权值
4. 若权值集大于1，则重复第二步，等于1则哈夫曼树构造完成



从上述哈夫曼树构造过程中可以看出，**所有带有权值的字符一定都在叶子结点**， 由于都在叶子结点，避免了某一字符编码前缀包含了另一字符编码，造成编码的二义性。





[参考资料：哈夫曼树原理及其构造](https://blog.csdn.net/qq_29519041/article/details/81428934)



### 二叉搜索树

> 也叫做二叉排序树，BST树（Binary Search Tree）是基于二叉树

![](https://upload-images.jianshu.io/upload_images/9738807-6b37320f910e1fb7.png?imageMogr2/auto-orient/strip|imageView2/2/w/311/format/webp)

#### 性质

* 若左子树不为空，则所有左子树的值都小于根节点的值
* 若右子树不为空，则所有右子树的值都大于根节点的值
* 左右子树都满足BST树的性质
* 中序遍历后，是有序数组，因此查找值时，**具有二分的性质**



#### 相关操作

##### 查找

根据BST树的性质，BST树的查找方式类似于**二分查找**，查找次数与树的深度有关，因此平均时间复杂度为$O(log_2N)$

```cpp
// 递归版
TreeNode* BSTSearch(TreeNode* root, int target) {
    if (root->val == target) return root;
    else if (root->val > target) return BSTSearch(root->left, target);
    else return BSTSearch(root->right, target);
    return NULL;
}

// 迭代版
TreeNode* BSTSearch(TreeNode* root, int target) {
    while (root) {
        if (root->val == target) return root;
        else if (root->val > target) root = root->left;
        else root = root->right;
    }
    return NULL;
}
```



##### 插入

* 插入也是基于查找实现的，若根节点的值等于待插入值则返回表示存在

* 若根节点值大于待插入值则向左子树查询
* 左子树为空，说明找到插入位置，将待插入值插入
* 左子树不为空，则向左子树查找
* 若根节点值小于待插入值则向右子树查询
* 右子树为空，说明找到插入位置，将待插入值插入
* 右子树不为空，则向右子树查找

```cpp
// root是根结点 node表示待插入结点
// 递归版
void BSTInsert(TreeNode* root, TreeNode* node) {
    if (root == nullptr || root->val == node->val) return;
    if (root->val > node->val) {
        if (root->left) BSTInsert(root->left, node);
        else root->left = node;
    } else {
        if (root->right) BSTInsert(root->right, node);
        else root->right = node;
    } 
}

// 迭代版
void BSTInsert(TreeNode* root, TreeNode* node) {
    while (root && root->val != node->val) {
        if (root->val > node->val) {
            if (root->left) root = root->left;
            else root->left = node, root = node;        
        } else {
            if (root->right) root = root->right;
            else root->right = node, root = node;          
        }
    }
}
```



##### 删除

删除结点还需要考虑怎么接上将待删除结点的左右子树接上，因此大致删除有三种情况

1. 待删除结点无孩子结点
2. 待删除结点只有一个孩子结点

3. 待删除结点有两个孩子结点

第一种情况

红色为待删除结点，该结点为叶子结点，找到直接删除即可

![](https://upload-images.jianshu.io/upload_images/9738807-3198aaba4a6ddbc6.png?imageMogr2/auto-orient/strip|imageView2/2/w/169/format/webp)

第二种情况

待删除结点只有一个孩子结点时，只需要将结点5右孩子结点指向6，删除结点7即可



![](https://upload-images.jianshu.io/upload_images/9738807-cbf680f5701e2644.png?imageMogr2/auto-orient/strip|imageView2/2/w/169/format/webp)



第三种情况

待删除结点有两个孩子结点，我们的思路是从待删除结点中找到一个值来替代结点，并删除替代结点，这个过程还需要保持BST树原来的性质

我们可以找**待删除结点**中**左子树中值最大的结点**，或者**右子树中值最小的结点**作为替代结点

而找该替代结点后的删除结点的工作便是我们之前分析的情况1和情况2中的一种



![](https://upload-images.jianshu.io/upload_images/9738807-6304a0221a05d3c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/327/format/webp)



```cpp
// 递归版
TreeNode* BSTDelete(TreeNode* root, int val) {
    if (root == nullptr) return NULL;
    if(root->val > val) root->left = BSTDelete(root->left, val);
    else if (root->val < val) root->right = BSTDelete(root->right, val);
    else {
        if (root->left && root->right) {					    // 情况3
            TreeNode* target = root->left;						// 找左子树最大
            while (target->right) target = target->right;
            root = BSTDelete(root, target->val);
            root->val = target->val;
        } else {												// 情况1和2
            if (root->left) root = root->left;					
            else root = root->right;
        }
    }
    return root;
}

```





[参考资料：二叉搜索树](https://www.jianshu.com/p/ff4b93b088eb)

[浙江大学数据结构二叉搜索树部分](https://www.icourse163.org/learn/ZJU-93001#/learn/announce)



### AVL树

> 平衡二叉搜索树(BBST)的一种



#### 性质

1. 是一颗二叉搜索树
2. 左右子树高度差的绝对值（平衡因子）最多为1



#### 相关操作

[详细图文——AVL树](https://blog.csdn.net/qq_25343557/article/details/89110319)



### 红黑树

结点包含5个域：color、key、left、right、p，其中如果某结点没有一个子结点或者父结点，则指针域p为NIL值，这个指针域看作是红黑树的叶子结点

#### 性质

1. 符合二叉搜索树的性质

2. 结点为红色或者黑色

3. 根结点为黑色

4. 叶子结点（NIL）为黑色

5. 每个红色结点的两个子结点都为黑色

6. 从任意结点到其每个叶子结点的所有路径都包含相同数目的黑色结点

![](https://upload-images.jianshu.io/upload_images/2392382-4996bbfb4017a3b2.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)

<center>一颗简单的红黑树</center>



[30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)



### B树/B+树





### 伸展树、主席树





### 相关习题(有亿点点多...)

| 题目链接                                                     | 说明                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) | 前序遍历模板                         |
| [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) | 前序遍历拓展                         |
| [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 中序遍历模板                         |
| [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) | 后序遍历模板                         |
| [590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) | 后序遍历拓展                         |
| [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) | 层序遍历模板                         |
| [107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) | 层序遍历模板变形                     |
| [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) | 层序遍历拓展                         |
| [429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) | 层序遍历拓展                         |
| [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) | 层序遍历拓展                         |
| [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/) | 层序遍历拓展                         |
| [100. 相同的树](https://leetcode-cn.com/problems/same-tree/) | 递归判断                             |
| [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) | 递归判断                             |
| [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) | 递归判断                             |
| [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) | 递归记录最大深度                     |
| [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) | 递归记录到叶子结点的最少结点数       |
| [559. N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) | 递归，叶子结点比较最大深度           |
| [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/) | 递归，找左右子树最大深度             |
| [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/) | 层序遍历变形题                       |
| [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/) | 递归求左右子树最长的路径             |
| [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/) | 遍历变形                             |
| [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/) | 递归终点为叶子结点模板               |
| [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)  | 递归终点为叶子结点模板               |
| [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) | 递归终点为叶子结点模板               |
| [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/) | 递归套递归                           |
| [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) | 递归求左右子树最大路径和             |
| [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/) | 遍历模板                             |
| [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) | 遍历模板                             |
| [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/) | 二叉搜索树搜索模板                   |
| [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/) | 二叉搜索树删除模板                   |
| [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/) | 二叉搜索树插入模板                   |
| [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) | 基于分治思想，构造二叉搜索树         |
| [1382. 将二叉搜索树变平衡](https://leetcode-cn.com/problems/balance-a-binary-search-tree/) | 构造平衡的二叉搜索树                 |
| [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/) | 了解卡特兰数                         |
| [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) | 基于分治思想枚举所有二叉搜索树       |
| [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/) | 中序遍历模板                         |
| [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) | 根据二叉搜索树的性质                 |
| [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) | 后序遍历                             |
| [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/) | 迭代中序遍历，平摊的时间复杂度为O(1) |
| [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) | 遍历+字符串构造二叉树                |
| [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/) | 理解压缩编码思想即可                 |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | 找根再分治处理                       |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) | 找根再分治处理                       |







## 堆

> 堆(heap)经常用于实现优先队列(priority queue)即每次从队列取出来的都是优先级最高的元素



### 性质

1. 堆是一个完全二叉树

2. 堆的两个子堆也满足堆的性质

3. 大根堆根上为最大元素，小根堆根上为最小元素
4. 参考本篇二叉树的性质5

堆一般采用静态数组来实现

### 模板

```cpp
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

// 向下调整
void down(int u) {
    int t = u;
    if (2 * u <= n && h[t] > h[2 * u]) t = 2 * u;
    if (2 * u + 1 <= n && h[t] > h[2 * u + 1]) t = 2 * u + 1;
    if (t != u) {
        heap_swap(t, u);
        down(t);
    }
}

// 向上调整
void up(int u) {
    while (u >> 1 && h[u] < h[u >> 1]) {
        heap_swap(u, u >> 1);
        u >>= 1;
    }
}

// 建堆
for (int i = n / 2; i; i -- ) down(i);
```







### STL常用方法

```cpp
// 默认大根堆
priority_queue<int, vector<int>>
// 小根堆
priority_queue<int, vector<int>, greater<int>>

// 方法同queue
top 访问堆顶元素
empty 判断是否为空
size 返回堆的元素个数
push 插入元素同时维护堆的性质
pop 弹出堆顶元素同时维护堆的性质

    
```









### 相关习题

| 题目链接                                                     | 说明                                |
| ------------------------------------------------------------ | ----------------------------------- |
| [838. 堆排序](https://www.acwing.com/problem/content/840/)   | 需要注意建堆方式                    |
| [839. 模拟堆](https://www.acwing.com/problem/content/841/)   | 需要维护第k个插入的数及其在堆的下标 |
| [148. 合并果子](https://www.acwing.com/problem/content/150/) | 贪心+堆                             |
| [145. 超市](https://www.acwing.com/problem/content/147/)     | 贪心+堆                             |
| [146. 序列](https://www.acwing.com/problem/content/148/)     | 两路归并思想+堆                     |





## 并查集

### 作用

1. 将两个集合合并
2. 判断元素属于哪个集合





### 并查集的相关操作

1. 初始化数组（代表每个结点的父节点）将每一个结点的父节点设置为自己表示为根节点，即p[i] = i
2. 查找元素所属的集合（find），则不断利用数组p寻找父结点直到p[i] = i，即while (p[i] != i) find(p[i])
3. 合并两个集合操作（union），找到两个集合的根结点，将一个结点的父节点设置成另一个结点





### 并查集优化

1. 按秩归并：基本思路是将较少结点的根节点指向包含较多的根节点

   

2. 路径压缩：在进行find操作时同时将所有子结点的根节点设置为该集合的根节点，减少了子结点到根节点的距离



### 并查集模板

```cpp
// 初始化
for (int i = 1; i <= n; i++) p[i] = i;

// find(x) 表示查找结点x所在集合的根结点
int find(int x) {
    if (x == p[x]) return x;
    p[x] = find(p[x]);
}

// 将集合a合并到集合b
p[find(a)] = find(b)
    
// 带权并查集find版本
int find(int x) {
    if (x == p[x]) return x;
    int t = find(p[x]);
    dist[x] += dist[p[x]];
    return p[x] = t;
}    
```





### 相关习题

| 题目链接                                                     | 说明                               |
| ------------------------------------------------------------ | ---------------------------------- |
| [836. 合并集合](https://www.acwing.com/problem/content/838/) | 并查集模板                         |
| [1249. 亲戚](https://www.acwing.com/problem/content/1251/)   | 并查集裸题，注意输入输出           |
| [837. 连通块中点的数量](https://www.acwing.com/problem/content/839/) | 维护连通块点的数量                 |
| [1250. 格子游戏](https://www.acwing.com/problem/content/1252/) | 最小环问题                         |
| [517. 信息传递](https://www.acwing.com/problem/content/519/) | 找最小环                           |
| [914. 樱桃网](https://www.acwing.com/problem/content/916/)   | 最小生成树                         |
| [237. 程序自动分析](https://www.acwing.com/problem/content/239/) | 维护相等的集合                     |
| [238. 银河英雄传说](https://www.acwing.com/problem/content/240/) | 维护结点到根节点的距离和集合的大小 |
| [239. 奇偶游戏](https://www.acwing.com/problem/content/241/) | 用来维护前缀和与根节点的奇偶性关系 |
| [240. 食物链](https://www.acwing.com/problem/content/242/)   | 维护结点到根节点的距离             |
| [257. 关押罪犯](https://www.acwing.com/problem/content/259/) | 贪心+带权并查集                    |
| [258. 石头剪子布](https://www.acwing.com/problem/content/260/) | 枚举某个人为裁判+带权并查集        |
| [784. 强盗团伙](https://www.acwing.com/problem/content/description/786/) | 合并同一活的强盗                   |
| [1242. 修改数组](https://www.acwing.com/problem/content/1244/) | 集合根节点维护没用过的数           |



## 字符串

### 模板

```cpp

```





### KMP

[参考：从头到尾彻底理解KMP](https://www.cnblogs.com/zhangtianq/p/5839909.html)



### STL常用方法



## 字典树

### Trie

```cpp
int son[N][26], cnt[N], inx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ inx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```



### 相关习题

| 题目链接                                                     | 说明   |
| ------------------------------------------------------------ | ------ |
| [835. Trie字符串统计](https://www.acwing.com/problem/content/837/) | 模板题 |
| [142. 前缀统计](https://www.acwing.com/problem/content/144/) | 模板题 |
| [143. 最大异或对](https://www.acwing.com/problem/content/145/) |        |





## 哈希表

### STL常用方法

```cpp

```









## 递推、位运算、快速幂









## 递归和回溯





## 简单的DFS与BFS





## DFS与剪枝





## 建图方式与最短路





## 拓扑排序与最短路应用









## 动态规划

### 线性DP

### 背包

### 区间DP

### 树形DP

### 状态压缩DP

### 状态机模型

### 其它





## 树状数组与线段树





## 贪心







## 数论









## 博弈论

