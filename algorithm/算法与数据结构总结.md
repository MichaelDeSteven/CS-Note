# 算法与数据结构总结

> 常用算法以及思想包括了**二分、前缀和、差分、枚举、倍增、递推、动态规划、双指针、排序、贪心、图论相关的包括DFS、BFS、最短路**、二分图、最小生成树等、数论相关的有**辗转相除法、拓展欧几里得、线性筛素数**等、还有一些博弈论的相关结论、相关字符串算法
>
> 数据结构包括了：数组**链表**、**队列、栈、堆**的概念和应用（包括了**单调队列**、**单调栈**）、哈希表的应用、树包括了**二叉搜索树**，**Trie**，还有一些复杂的（B树、B+树、平衡树、红黑树这些了解即可），图的数据结构（基于邻接矩阵、邻接表、前向星的**建图**方法）、**并查集**、树状数组与线段树简单应用
>
> 我们还可以利用相关技巧如**位运算**、**哨兵**写出更简洁的代码
>
> 本篇用于总结以上算法与数据结构以及相关技巧，再结合其应用来更好地理解与巩固基础



## 算法概述

### 算法

> 定义：给出确定和完整地指令，再给定一组输出，算法能够在有限地时间获得输出结果

#### 性质

* 有限性
* 确定性
* 有输入输出
* 有效性

#### 常用的算法思想

递推、倍增、枚举、贪心、分治、迭代、回溯



#### 时间复杂度和空间复杂度

* 复杂度一般用O表示法，表示一个函数运行的渐进上界

![](http://static.oschina.net/uploads/space/2014/0426/210036_kKPH_1246663.png)



#### 时间复杂度反推算法

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%8F%8D%E6%8E%A8%E7%AE%97%E6%B3%95.png?raw=true)

## 数据结构概述

### 数据结构

> 定义：计算机中存储与组织特定关系的数据元素的方式

#### 逻辑结构

> 反映数据之间的逻辑关系

1. 线性结构：元素之间一对一的关系，
2. 树形结构：元素之间一对多或者多对一的关系
3. 图形结构：元素之间多对多的关系

#### 物理结构

1. 顺序存储：元素在内存中按顺序存放，可随机存取元素，插入或删除需要移动元素
2. 链接存储：由数据域与指针域构成，逻辑上相邻而物理上不必相邻，插入、删除灵活
3. 索引存储：除了存储结点信息外，还需要建立附加的索引表来表示结点的地址，索引表由若干个索引项组成
4. 散列存储：由键值对组成，通过关键字来存取值







## 二分

> 二分查找是一种高效率地查找，经典应用是在有序排列的数组找到目标值
>
> 二分查找的本质是找到某种性质，能将顺序表划分了两段，其中一段符合该性质，另一段不符合性质，即具有二段性



* 用于顺序表的查找

* 查找的时间复杂度为$O(log_2N)$,其中N为数据规模



### 模板

整数二分模板

```c++
// 查找区间右端点
int low = 0, high = n - 1;
while (low < high) {
    int mid = low + high + 1 >> 1;
    if (nums[mid] <= target) {				
        ll = mid;
    } else {
        rr = mid - 1;
    }
}


// 查找区间左端点
while (low < high) {
    int mid = low + high >> 1;
    if (nums[mid] >= target) {				
        rr = mid;
    } else {
        ll = mid + 1;
    }
}
```



浮点数二分模板

```c++
while (high - low > 1e-6) {							// 终止的条件为精度
    double mid = (low + high) / 2;					// 由于是浮点数，不能用右移的方式
    if (num[mid] >= target) {
        rr = mid;
    } else {
        ll = mid;
    }
}
```



### 相关习题

| 题目链接                                                     | 二分依据                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [704.二分查找](https://leetcode-cn.com/problems/binary-search/) | 有序数组，寻找区间端点                                       |
| [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/) | 有序数组，第一个位置即第一个大于等于目标值(区间向左缩)，最后一个位置即最后一个小于等于目标值(区间向右缩) |
| [剑指 Offer 53 - II. 0～n-1中缺失的数字](https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/) | 某点下标与值相同，缺失的数字则一定在右区间，反之则一定在左区间（区间向左缩） |
| [69. x 的平方根](https://leetcode-cn.com/problems/sqrtx/)    | 由于只保留整数部分，可以看作需要查找最大的mid满足x >= mid^2（区间向右缩） |
| [35. 搜索插入位置](https://leetcode-cn.com/problems/search-insert-position/) | 目标值不存在数组则按顺序插入，即寻找最后一个小于等于目标值的位置（区间向右缩） |
| [852. 山脉数组的峰顶索引](https://leetcode-cn.com/problems/peak-index-in-a-mountain-array/) | 三分可解决，用二分则通过mid与mid + 1比较                     |
| [162. 寻找峰值](https://leetcode-cn.com/problems/find-peak-element/) | nums[mid] > nums[mid + 1],mid左区间(包含mid)必定存在峰值，区间向左缩 |
| [1095. 山脉数组中查找目标值](https://leetcode-cn.com/problems/find-in-mountain-array/) | 二分套二分，先用二分寻找峰值，峰值左右两边再二分找目标值     |
| [1237. 找出给定方程的正整数解](https://leetcode-cn.com/problems/find-positive-integer-solution-for-a-given-equation/) | 枚举变量x，由于f(x,y)为严格单调，因此可以对y进行二分，使得f(x, y) - z == 0 |
| [278. 第一个错误的版本](https://leetcode-cn.com/problems/first-bad-version/) | 寻找第一个出错的版本，区间向左缩，需要考虑mid计算溢出        |
| [153. 寻找旋转排序数组中的最小值](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) | min{前一部分数组} > max{后一部分数组}因此下标为mid的值与右区间端点比较，具有二段性，小于右区间端点，最小值在mid左边，区间向左缩 |
| [154. 寻找旋转排序数组中的最小值 II](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，右指针向左移动一位排除相同的值 |
| [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/) | 分析可得min{前一部分数组} > max{后一部分数组}，二分找到旋转点，选择一个区间进行二分 |
| [81. 搜索旋转排序数组 II](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/) | 思路同上min{前一部分数组} >= max{后一部分数组}，需要特判从结尾排除与nums[0]相同的值 |
| [1011. 在 D 天内送达包裹的能力](https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/) | 枚举运载能力x，若d天内x能完成，则大于等于x的运载能力都能完成，即具有二段性 |
| [P1182 数列分段 Section II](https://www.luogu.com.cn/problem/P1182) | 枚举最大值，每个段子数组的和不应该超过最大值，若无法找到这样的情况则最大值不能再枚举更小的数，即具有二段性 |
| [1221. 四平方和](https://www.acwing.com/problem/content/1223/) | 预处理二元组，根据主键顺序排序，枚举前两个的平方和再根据二元组的大小进行二分 |
| [1227. 分巧克力](https://www.acwing.com/problem/content/1229/) | 对巧克力边长进行二分                                         |
| [730. 机器人跳跃问题](https://www.acwing.com/problem/content/732/) | 对初始能量进行二分                                           |



## 前缀和、差分

> 前缀和运用了递推的思想，经典的空间复杂度换时间时间复杂度的策略

### 前缀和

#### 一维前缀和

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%B8%80%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C.png?raw=true)

设数组为$a[i],i > 0$,前缀和s数组表示为$s[i] = \sum^{i}_{j=1}a[j]$，则一维前缀和公式为$s[i] - s[j - 1] = \sum_{k=i}^{j}a[k],其中s[0]定义为0$

#### 二维前缀和

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C1.png?raw=true)

* 与一维前缀和类似的，值从下标为1开始存储，并定义$a[i][j] = 0，i = 0 || j = 0$

![image-20200806201419354](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C2.png?raw=true)

* 倘若要计算红色部分+蓝色部分+橙色部分+黑色部分即$S_{3,3}$，那么先计算出红色部分+橙色部分即$S_{2,3}$，再计算出红色部分+蓝色部分即$S_{3,2}$
* 由**容斥定理**可知，我们需要再**减去一个红色部分**，$S_{3,3} = S_{2,3} + S_{3,2} - S_{2,2} + a[i][j]$ 



![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E4%BA%8C%E7%BB%B4%E5%89%8D%E7%BC%80%E5%92%8C3.png?raw=true)



类似的利用上述方法，我们可以计算出子矩阵的前缀和

* 红色矩阵是需要求的子矩阵和，蓝色部分左上角即原矩阵的左上角，右下角为红色矩阵的右下角
* 由**容斥定理**得，红色部分 = 蓝色部分 - 粉色部分 - 橙色部分 + 粉色部分与橙色部分重叠部分



**二维前缀和公式**

* 对数组a进行处理，得到前缀和矩阵$s[i][j] = a[i][j] + s[i - 1][j] + s[i][j - 1]$   i,j均为正整数

* 对任意子矩阵，左上角为$(i,j)$,右下角为$(x,y)$有如下公式
  $$
  S_{(i,j), (x,y)} = S_{(0,0), (x,y)} - S_{(0,0), (x - 1,y)} - S_{(0,0), (x,y - 1)} + S_{(0,0), (i - 1,j - 1)}
  $$
  其中$S_{(0,0),(x,y)}$即为前缀和矩阵$s[x][y]$ 

### 差分

#### 一维差分

```cpp
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```



#### 二维差分

```cpp
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```





### 相关习题

| 题目链接                                                     | 思路                                   |
| ------------------------------------------------------------ | -------------------------------------- |
| [1236. 递增三元组](https://www.acwing.com/problem/content/1238/) | 利用前缀和统计大于等于和小于等于bi的数 |
| [1230. K倍区间](https://www.acwing.com/problem/content/1232/) | 抓住s[i] % k = s[j] % k条件            |
| [102. 最佳牛围栏](https://www.acwing.com/problem/content/104/) | 前缀和+二分的应用                      |
| [796. 子矩阵的和](https://www.acwing.com/problem/content/798/) | 二维前缀和模板                         |
| [99. 激光炸弹](https://www.acwing.com/problem/content/101/)  | 二维前缀和应用                         |
| [797.差分](https://www.acwing.com/problem/content/799/)      | 模板题                                 |
| [798. 差分矩阵](https://www.acwing.com/problem/content/800/) | 二维差分矩阵模板                       |
| [101. 最高的牛](https://www.acwing.com/problem/content/103/) | 差分应用                               |





## 双指针和排序

### 双指针



> 双指针的思想应用范围很广





### 排序



#### 0. 十大排序算法比较

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

#### 1. 插入排序



1. 算法思路
   * 从未排序中的数组选择一个元素e插入到已排序好的数组中
   * 按倒序顺序遍历已排序好的数组（遍历的值设为x）逐个与e进行比较
   * 若x大于元素e，则将将x向后移动一位，若x小于等于则将e插入该位置
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```c++
void insert(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        int j = i, e = arr[i];
        while (j > l && arr[j - 1] > e) arr[j] = arr[j - 1], j--;
        arr[j] = e;
    }
}
```



#### 2. 选择排序

1. 算法思路

   * 每次从未排序的数组中选择一个最小的元素e
   * 将元素e插入到已排序数组的末尾
   * 重复上述步骤，直到所有元素都已排序

2.  代码实现

   ```c++
   void select(int l, int r, int arr[]) {
       for (int i = l; i <= r; i++) {
           int inx = i;
           for (int j = i; j <= r; j++) {
               if (arr[j] < arr[inx]) inx = j;
           }
           swap(arr[inx], arr[i]);
       }
   }
   ```



#### 3. 希尔排序

> 简单插入排序的改良版本,又称缩小增量排序，实质是分组的插入排序
>
> * 希尔排序的时间复杂度和增量序列是相关的



```cpp
void shell(int l, int r, int arr[]) {
    int len = r - l + 1;
    for (int i = len >> 1; i > 0; i >>= 1) {
        for (int j = i; j <= r; j++) {
            int k = j, e = arr[k];
            while (k >= i && arr[k - i] > e) arr[k] = arr[k - i], k -= i;
            arr[k] = e;
        }
    }
}
```







#### 4. 冒泡排序

1. 算法思路 

   * 每次从头开始相邻两个元素比较
   * 若前一个元素大于后一个元素则交换
   * 到数组结尾则完成这一轮的操作
   * 若某一轮次未有交换发生则说明该数组已排好序，提前退出
   * 重复上述步骤，直到所有元素都已排序

2. 代码实现

```cpp
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) swap(arr[j], arr[j + 1]);
        }
    }
}



// 优化的代码
void bubble(int l, int r, int arr[]) {
    for (int i = l; i <= r; i++) {
        bool flag = true;
        for (int j = l; j < r + l - i; j++) {
            if (arr[j] > arr[j + 1]) {
                flag = false;
                swap(arr[j], arr[j + 1]);
            }
        }
        if (flag) break;
    }
}
```





#### 5. 快速排序

1. 算法思路

   * 确定一个基准值pivot
   * 小于等于pivot的值放在数组前半部分，大于等于pivot的值放在数组后半部分
   * 分别对数组前半部分和后半部分递归，直到区间长度为1

2. 代码实现

```cpp
// 递归实现
void quick(int l, int r, int arr[]) {
    if (l >= r) return;
    int i = l - 1, j = r + 1, x = arr[i + j >> 1];
    
    while (i < j) {
        do i++; while (arr[i] < x);
        do j--; while (arr[j] > x);
        if (i < j) swap(arr[i], arr[j]);
    }

    quick(l, j, arr), quick(j + 1, r, arr);
}

// 迭代实现
int partition(int a[], int l, int r) {
    int i = l - 1, j = r + 1, x = a[i + j >> 1];
    
    while (i < j) {
        do i++; while (a[i] < x);
        do j--; while (a[j] > x);
        if (i < j) swap(a[i], a[j]);
    }
    return j;
}

void quicksort(int a[], int ll, int rr) {
    stack<int> stk;
    stk.push(rr);
    stk.push(ll);
    
    while (!stk.empty()) {
        int low = stk.top();
        stk.pop();
        int high = stk.top();
        stk.pop();
        if (low < high) {
            int inx = parition(a, low, high);
            stk.push(high);
            stk.push(inx + 1);
            stk.push(inx);
            stk.push(low);
        }
    }
}
```







#### 6. 归并排序

> 归并排序是稳定的排序，时间复杂度也是稳定的，其代价是需要额外的内存空间

![](https://camo.githubusercontent.com/ce0f02cdc800ad02551271b79ecc6a778280a41b/68747470733a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f313032343535352f3230313631322f313032343535352d32303136313231383136333132303135312d3435323238333735302e706e67)

1. 算法思路

   * 将区间一分为二，对两个区间进行递归，直到区间大小为1，自顶向下
   * 对这两个区间进行归并（这两个区间都是有序的），放在另一个数组中

   * 再将另一个数组复制到原数组

2. 代码实现

```cpp
// 递归实现
void merge(int l, int r, int arr[]) {
    if (l >= r) return;
    int mid = l + r >> 1, i = l, j = mid + 1, k = 0;
    merge(l, mid, arr), merge(mid + 1, r, arr);
    
    while (i <= mid && j <= r) {
        if (arr[i] > arr[j]) cop[k++] = arr[j++];
        else cop[k++] = arr[i++];
    }
    
    while (i <= mid) cop[k++] = arr[i++];
    while (j <= r) cop[k++] = arr[j++];
    
    for (int i = l, k = 0; i <= r; i++, k++) arr[i] = cop[k];
}

// 迭代实现
void merge(int a[], int ll, int mid, int rr) {
    if (ll >= rr) return;
    int i = ll, j = mid + 1, k = 0;
    while (i <= mid && j <= rr) {
        if (a[i] < a[j]) t[k++] = a[i++];
        else t[k++] = a[j++];
    }
    
    while (i <= mid) t[k++] = a[i++];
    while (j <= rr) t[k++] = a[j++];
    
    for (i = ll, j = 0; j < k; j++, i++) {
        a[i] = t[j];
    }
}

void mergePass(int a[], int k, int ll, int rr) {
    int i = ll;
    for (; i + 2*k - 1 <= rr; i += 2*k) {
        merge(a, i, i + k - 1, i + 2*k - 1);
    }
    
    if (i + k < rr) {
        merge(a, i, i + k - 1, rr);
    }
}

void mergeSort(int a[], int ll, int rr) {
    int k = 1, len = rr - ll + 1;
    while (k < len) {
        mergePass(a, k, ll, rr);
        k <<= 1;
    }
}

```





#### 7. 堆排序

> 借助堆的数据结构

1. 算法思路

   * 建堆
   * 打印当前位于堆的最大值或最小值
   * 将堆最后一个编号的值移动到堆顶
   * 维护堆的性质

2. 代码实现

```cpp
void down(int u) {
    int t = u;
    if (2 * u <= n && h[t] > h[2 * u]) t = 2 * u;
    if (2 * u + 1 <= n && h[t] > h[2 * u + 1]) t = 2 * u + 1;
    if (t != u) {
        swap(h[t], h[u]);
        down(t);
    }
}

// 建堆
for (int i = n / 2; i >= 0; i--) down(i);
// 输出结果
for (int i = 1; i <= m; i++) {
    cout << h[1] << ' ';
    h[1] = h[n--];
    down(1);
}
```



#### 8.计数排序



* 空间换时间的思想

* 计算出最小和最大值，确定区间范围
* 对范围的每个数确定个数
* 按顺序输出结果





#### 9.桶排序



* 计数排序的升级版
* 对每个数取模运算并放入桶中
* 对每个桶进行排序
* 按顺序输出结果





#### 10.基数排序



* 计算序列中的最大位数
* 从低位优先或者高位优先原则，按数的某位放入指定桶中
* 按顺序收集桶中的数
* 循环最大位数次后即得到结果







**参考资料**：[十大经典排序](https://www.cnblogs.com/onepixel/articles/7674659.html)





## 高精度与离散化



### 高精度

> 包含了高精度的大整数加减乘除运算

* A：高精度数字如何存储？

  Q：数组低地址存低位

#### 高精度加法



```cpp
vector<int> add(vector<int>& a, vector<int>& b) {
    int res = 0;
    vector<int> c;
    for (int i = 0; i < a.size() || i < b.size(); i++) {
        if (i < a.size()) res += a[i];
        if (i < b.size()) res += b[i];
        c.push_back(res % 10);
        res /= 10;
    }
    if (res) c.push_back(res);
    return c;
}
```



#### 高精度减法

```c++
// 需要保证a >= b,且a、b均为非负数
vector<int> sub(vector<int>& a, vector<int>& b) {
    vector<int> c;
    int res = 0;
    for (int i = 0; i < a.size(); i++) {
        res = a[i] - res;
        if (i < b.size()) res -= b[i];
        c.push_back((res + 10) % 10);
        if (res < 0) res = 1;
        else res = 0;
    }
    // 去除前导0
    while (c.size() > 1 && c[c.size() - 1] == 0) c.pop_back();
    return c;
}
```



#### 高精度乘法

```cpp
// a*b, b为低精度
vector<int> mul(vector<int>& a, int b) {
    int t = 0;
    vector<int> res;
    for (int i = 0; i < a.size(); i++) {
        t += b * a[i];
        res.push_back(t % 10);
        t /= 10;
    }
    
    while (t) {
        res.push_back(t % 10);
        t /= 10;
    }
    // 去除前导0
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}

// a*b, a、b均为高精度
vector<int> mul(vector<int>& a, vector<int>& b) {
    int t = 0;
    vector<int> res(a.size() + b.size(), 0);
    for (int i = 0; i < a.size(); i++) {
        for (int j = 0; j < b.size(); j++) {
            res[i + j] += a[i] * b[j];
        }
    }
    
    for (int i = 0; i < res.size(); i++) {
        t += res[i];
        res[i] = t % 10;
        t /= 10;
    }
    // 去除前导0
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}
```



#### 高精度除法

```cpp
// b为低精度, t为余数
vector<int> div(vector<int>& a, int b) {
    vector<int> res;
    // 模拟除法，从高位开始除
    for (int i = a.size() - 1; i >= 0; i--) {
        t = t * 10 + a[i];
        res.push_back(t / b);
        t %= b;
    }
    
    reverse(res.begin(), res.end());
    while (res.size() > 1 && res.back() == 0) res.pop_back();
    return res;
}
```





### 离散化

> 离散化的本质是映射。离散化的意义是将区间范围很大，而用到的值的个数少，且需要保持其值相对大小的集合进行映射



```cpp
// 离散化前的准备
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) { // 找到第一个大于等于x的位置
    int l = 0, r = alls.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}


// 哈希表映射
unordered_map<int, int> ma				// 采用unordered_map进行映射
for (auto i : all) ma[i] = ++cnt;       // 映射到1, 2, ...n
```





## 链表

>物理存储不连续，而逻辑上连续，相比于数组来说，删除和插入效率高，但是查找的效率比数组慢

### 常用技巧

* 头结点的使用，在单链表的第一个结点之前设置有一个结点，也称为哑结点，能简化代码逻辑
* 双指针算法：在链表中双指针一般指快慢指针



### 单链表

结构：由数据域和直接后驱指针域构成



### 双链表

结构：由数据域和直接前驱、直接后驱指针域构成



### 静态链表

> 常用于存图操作，解决了邻接表的链表结构实现慢，邻接矩阵开辟浪费空间的问题，静态链表也叫做前向星



#### 模板

```cpp
// inx表示插入的第inx个结点，h表示头结点，e[inx]表示第inx个结点存储的值，ne[inx]表示第inx个结点的下一个结点
int inx, h, e[N], ne[N];
// 初始化
h = -1, inx = 0;

// 插入头结点(链表不为空)
e[inx] = element, ne[inx] = ne[h], h = inx++;

// 删除第k个头结点
// k = 0，删除头结点
h = ne[h];
// k不为0
ne[k - 1] = ne[ne[k - 1]];

// 将结点插入到第k个结点
e[inx] = element, ne[inx] = ne[k - 1], ne[k - 1] = inx++;
```







### 相关习题

| 题目链接                                                     | 说明   |
| ------------------------------------------------------------ | ------ |
| [826. 单链表](https://www.acwing.com/problem/content/828/)   | 模板题 |
| [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/) |        |
| [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/) |        |
| [19. 删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) |        |
| [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/) |        |
| [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) |        |
| [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/) |        |
| [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/) |        |
| [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/) |        |
| [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) |        |
| [23. 合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) |        |
| [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/) |        |
| [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/) |        |
| [61. 旋转链表](https://leetcode-cn.com/problems/rotate-list/) |        |
| [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) |        |
| [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) |        |
| [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/) |        |
| [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/) |        |
| [138. 复制带随机指针的链表](https://leetcode-cn.com/problems/copy-list-with-random-pointer/) |        |
| [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/) |        |
| [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/) |        |
| [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/) |        |
| [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/) |        |
| [148. 排序链表](https://leetcode-cn.com/problems/sort-list/) |        |
| [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/) |        |
| [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/) |        |
| [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/) |        |
| [328. 奇偶链表](https://leetcode-cn.com/problems/odd-even-linked-list/) |        |
| [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/) |        |
| [817. 链表组件](https://leetcode-cn.com/problems/linked-list-components/) |        |
| [876. 链表的中间结点](https://leetcode-cn.com/problems/middle-of-the-linked-list/) |        |
| [1019. 链表中的下一个更大节点](https://leetcode-cn.com/problems/next-greater-node-in-linked-list/) |        |
| [1171. 从链表中删去总和值为零的连续节点](https://leetcode-cn.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/) |        |
| [1290. 二进制链表转整数](https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/) |        |
| [1367. 二叉树中的列表](https://leetcode-cn.com/problems/linked-list-in-binary-tree/) |        |
| [剑指 Offer 35. 复杂链表的复制](https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/) |        |
| [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/) |        |







## 队列与栈

### 模板

#### 普通队列模板

* 队列具有FIFO(First In First Out)特点

```cpp
// 普通队列, tt表示队尾指针，hh表示队头指针
int queue[N], tt = -1, hh = 0;

// 队尾入队
queue[++tt] = e;

// 是否为空
若hh > tt 则说明队列为空
    
// 队头出队
hh++
    
// 查询队头元素
queue[hh]
    
// 查询队尾元素
queue[tt]
```



#### 栈模板

* 堆栈具有FILO(First In Last Out)特点

```cpp
// 普通堆栈，hh表示栈顶指针
int stack[N], hh = 0;

// 判断是否为空
hh等于0则为空
    
// 入栈
stack[++hh] = e;

// 出栈
--hh;

// 查询栈顶元素
stack[hh]
    
// 查询大小
hh
```



#### 单调栈模板

```cpp
常见模型：找出每个数左边离它最近的比它大/小的数
int hh = 0, a[N];
for (int i = 1; i <= n; i ++ ) {
    while (hh && check(stk[hh], i)) hh--;
    a[i] = stk[hh];
    stk[ ++ hh] = i;
}

常见模型：找出每个数右边离它最近的比它大/小的数
for (int i = n; i > 0; i -- ) {
    while (hh && check(stk[hh], i)) hh--;
    a[i] = skt[hh];
    stk[ ++ hh] = i;
}

// 由于是逆序查找，所以需要翻转一下数组
reverse(a, a + n);
```



#### 单调队列模板

```cpp
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ ) {
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], a[i])) tt -- ;
    q[ ++ tt] = i;
}
```





### STL常用方法

```cpp
// queue普通队列
    size()
    empty() 
    push()  //向队尾插入一个元素
    front() //返回队头元素
    pop()   //弹出队头元素
    back()  //返回队尾元素

// stack栈
    size()
    empty()
    push()  //向栈顶插入一个元素
    top()   //返回栈顶元素
    pop()   //弹出栈顶元素
```



### 相关习题

| 题目链接                                                     | 说明                                           |
| ------------------------------------------------------------ | ---------------------------------------------- |
| [828. 模拟栈](https://www.acwing.com/problem/content/description/830/) | 模板                                           |
| [830. 单调栈](https://www.acwing.com/problem/content/832/)   | 利用单调栈，找到每个数离它左边最近的比它小的数 |
| [829. 模拟队列](https://www.acwing.com/problem/content/description/831/) | 模板                                           |
| [154. 滑动窗口](https://www.acwing.com/problem/content/description/156/) | 利用单调队列，在O(1)时间复杂度内找到区间的最值 |
| [651. 逛画展](https://www.acwing.com/problem/content/653/)   | 单调队列练习题                                 |
| [652. 切蛋糕](https://www.acwing.com/problem/content/654/)   | 单调队列练习题                                 |
| [135. 最大子序和](https://www.acwing.com/problem/content/description/137/) | 前缀和+单调队列                                |
| [剑指 Offer 09. 用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) | 下一题简化版                                   |
| [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/) | 两个栈来实现队列                               |
| [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/) | 两个队列来实现栈                               |
| [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/) | 利用栈验证                                     |
| [150. 括号画家](https://www.acwing.com/problem/content/152/) | 求最长连续有效括号                             |
| [71. 简化路径](https://leetcode-cn.com/problems/simplify-path/) | 栈的应用+字符串                                |
| [41. 包含min函数的栈](https://www.acwing.com/problem/content/90/) | 利用单调栈来维护最小值                         |
| [946. 验证栈序列](https://leetcode-cn.com/problems/validate-stack-sequences/) | 模拟                                           |
| [129. 火车进栈](https://www.acwing.com/problem/content/131/) | dfs+模拟栈                                     |
| [131. 直方图中最大的矩形](https://www.acwing.com/problem/content/133/) | 单调栈的应用                                   |
| [152. 城市游戏](https://www.acwing.com/problem/content/154/) | 上题拓展                                       |
| [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/) | 同上题思路                                     |
| [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/) | 直方图最大矩形类型的题                         |
| [496. 下一个更大元素 I](https://leetcode-cn.com/problems/next-greater-element-i/) | 查找右边最值问题                               |
| [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/) | 上题拓展                                       |
| [739. 每日温度](https://leetcode-cn.com/problems/daily-temperatures/) | 查找右边最值问题                               |
| [151. 表达式计算4](https://www.acwing.com/problem/content/153/) | 栈在表达式中的应用                             |
| [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/) | 表达式计算简单版                               |
| [735. 行星碰撞](https://leetcode-cn.com/problems/asteroid-collision/) | 栈的应用                                       |
| [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/) | 队列应用                                       |



## 树

### 树的定义及其术语

> 定义：除了根结点以外，每个结点有且仅有一个父结点，都拥有多个孩子结点，每个结点及其该结点的孩子结点组成的结合其结构也符合树的定义



* 叶子结点：无孩子的结点

* 结点的度：指孩子结点的个数

### 二叉树

> 二叉树的定义： 二叉树**要么为空**，要么每个结点**最多**只含有**两个直接孩子结点**，这两个直接孩子结点及其它们的孩子结点也分别称为左右子树，该左右子树符合二叉树的定义



#### 二叉树的性质

* 性质1

  二叉树第i层最多有$2^{i-1}$ 个结点, $i>=1$

* 性质2

  深度为k的二叉树最多有$2^k-1$个结点

* 性质3

  定义度为i的结点为$n_i$ ，则二叉树满足${n_2} + 1 = {n_0}$ 

  > 证明方法：
  >
  > 1. 首先树的总边数e与总结点数是满足于$e = n - 1$
  >
  > 上面的关系式可以理解成除了根结点以外，所有结点都对应一条与父结点的边，反过来，所有结点直接孩子的个数有关系式$n_1 + 2n_2 = e$
  >
  > 2. 总结点数有关系式$n = n_0 + n_1 + n_2$
  >
  > 3. $n_1 + 2n_2 + 1 = n_0 + n_1 + n_2$
  >
  >    即有${n_2} + 1 = {n_0}$

  

* 性质4

  具有n个结点的完全二叉树的深度为$\lfloor log_2n \rfloor + 1$

* 性质5

  完全二叉树中的某结点为i，则

  1）若存在父结点，则父结点编号为$[i / 2]$

  2）若存在左子结点，则编号为$2i$

  3）若存在右子结点，则编号为$2i+1$

#### 完全二叉树与满二叉树



> 完全二叉树定义：按从上到下从左到右的顺序，从1开始，给二叉树每个结点依次编号，若结点数为n，则所有结点**在且仅在**编号1到编号n中

> 满二叉树的定义：深度为k的二叉树中，有且仅有$2^k - 1$个结点

![](https://bkimg.cdn.bcebos.com/pic/7acb0a46f21fbe0961cdc7e561600c338644adab?x-bce-process=image/crop,x_0,y_3,w_600,h_396/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5)

### 二叉树的存储

##### 物理存储结构

1. 数组存储（适合于完全二叉树）
2. 链表存储

##### 逻辑存储结构

* 双亲表示法

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923203304500-1066380837.png)

* 孩子表示法(**常用**)

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204350058-771438158.png)

![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204035397-1294931058.png)



* 孩子兄弟表示法：

  ![img](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923212046972-354309866.png)



![](https://img2018.cnblogs.com/blog/1785151/201909/1785151-20190923204256034-1713840703.png)







### 二叉树的遍历

树的结构体定义如下

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
```



#### 先序遍历

**递归版先序遍历步骤**

1. 遍历根结点

2. 遍历左子树

3. 遍历右子树

**迭代版先序遍历版本1步骤**

1. 初始化一个空栈，将指针p置为根结点
2. 若指针p不为空，则先打印该结点的值，再将指针p压入栈中
3. 指针p更新为p的左子结点，重复步骤2直到p为空
4. 若栈不为空，将指针p更新为栈顶结点的右子结点，弹出栈顶元素
5. 重复2-4步骤，直到指针p为空且栈为空



**递归代码实现**

```cpp
void preorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    cout << root->val << endl;
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}
```



**迭代代码实现**

```cpp
// 版本1
void preorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
    	vector<int> res;
        while (!stk.empty() || root) {
            while (root) {
                res.push_back(root->val);					// 先打印
                stk.push(root);
                root = root->left;
            }
            if (!stk.empty()) root = stk.top()->right, stk.pop();
        }
}

// 版本2
void preorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
    	vector<int> res;
    	if (root) stk.push(root);
        while (!stk.empty()) {
            root = stk.top(), stk.pop();
            res.push_back(root->val);
            if (root->right) stk.push(root->right);
            if (root->left) stk.push(root->left);
        }
}
```





#### 中序遍历

**递归版先序遍历步骤**

1. 遍历左子树

2. 遍历根结点

3. 遍历右子树

**迭代版中序遍历步骤**

1. 初始化一个空栈，将指针p置为根结点
2. 若指针p不为空，则将指针p压入栈中
3. 指针p更新为p的左子结点，重复步骤2直到p为空
4. 若栈不为空，打印栈顶结点的值，再将指针p更新为栈顶结点的右子结点，弹出栈顶元素
5. 重复2-4步骤，直到指针p为空且栈为空



**递归代码实现**

```cpp
void inorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    inorderTraversal(root->left);
    cout << root->val << endl;
    inorderTraversal(root->right);
}
```



**迭代代码实现**

```cpp
void inorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
        while (!stk.empty() || root) {
            while (root) {
                stk.push(p);
                root = root->left;
            }
            res.push_back(stk.top()->val);			// 遍历完左子树，再打印
            root = stk.top()->right, stk.pop();
        }
}
```



#### 后序遍历

**递归版后序遍历步骤**

1. 遍历左子树
2. 遍历右子树
3. 遍历根结点

**迭代版后序遍历步骤**

类似与先序遍历的迭代实现，将访问顺序调整为根右左，最后将结果反转即为后序遍历





**递归代码实现**

```cpp
void postorderTraversal(TreeNode* root) {
    if (root == nullptr) return;
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    cout << root->val << endl;
}
```



**迭代代码实现**

```cpp
// 版本1
void postorderTraversal(TreeNode* root) {
        stack<TreeNode*> stk;
    	vector<int> res;
        while (!stk.empty() || root) {
            while (root) {
                res.push_back(stk.top()->val);
                stk.push(root);
                root = root->right;
            }
            root = stk.top()->left, stk.pop();
        }
    	reverse(res.begin(), res.end());
}

// 版本2
void postorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        if (root) stk.push(root);
        while (!stk.empty()) {
            root = stk.top(), stk.pop();
            res.push_back(root->val);
            if (root->left) stk.push(root->left);
            if (root->right) stk.push(root->right);
        }
        reverse(res.begin(), res.end());
        return res;
}
```







#### 层序遍历

**迭代步骤**

1. 初始化一个空队列，将根结点插入队尾
2. 每次从队列取出队头元素，同时将队头元素出队
3. 若存在左子结点则插入队尾，若存在右子结点则插入队头
4. 重复2、3步骤，直到队列为空



**代码实现**

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    queue<TreeNode*> q;
    vector<vector<int>> res;
    if (root) q.push(root);
    while (!q.empty()) {
        int sz = q.size();
        vector<int> tmp;
        for (int i = 0; i < sz; i++) {
            root = q.front();
            q.pop();
            tmp.push_back(root->val);
            if (root->left) q.push(root->left);
            if (root->right) q.push(root->right);
        }
        res.push_back(tmp);
    }
    return res;
}
```





### 哈夫曼树

> 哈夫曼树也叫最优二叉树，用于对信息进行编码，原则是将出现率高的字母使用较短的编码，使得哈夫曼树是带权路径长度最小的树，从而减少了信息编码的长度，哈夫曼树算法是基于贪心的思想



#### 相关术语

* 路径： 树的结点到另一个结点之间的路径

* 路径长度：路径上边的数目

* 树的路径长度：根结点到每个结点的路径长度之和

  哈夫曼树将字符存在了每一个叶子结点，将每一个叶子结点值定义为权值，**哈夫曼树中权值越大，该结点说明出现的频率越高**

* 树的带权路径长度：树中全部叶子结点的带权路径长度之和，即$WPL = \sum_{k=1}^{n}{w_kl_k}$

相关计算

![](https://img2018.cnblogs.com/blog/1281523/201904/1281523-20190429151920686-1528959792.png)



#### 哈夫曼树算法步骤

1. 先统计所有字符出现的频率，分配权值
2. 从权值集中每次找最小的两个权值，权值小的左边，大的右边，两个结点权值之和作为根结点
3. 删除权值集中这个两个最小的权值，并加入该根结点的权值
4. 若权值集大于1，则重复第二步，等于1则哈夫曼树构造完成



从上述哈夫曼树构造过程中可以看出，**所有带有权值的字符一定都在叶子结点**， 由于都在叶子结点，避免了某一字符编码前缀包含了另一字符编码，造成编码的二义性。





[参考资料：哈夫曼树原理及其构造](https://blog.csdn.net/qq_29519041/article/details/81428934)



### 二叉搜索树

> 也叫做二叉排序树，BST树（Binary Search Tree）是基于二叉树

![](https://upload-images.jianshu.io/upload_images/9738807-6b37320f910e1fb7.png?imageMogr2/auto-orient/strip|imageView2/2/w/311/format/webp)

#### 性质

* 若左子树不为空，则所有左子树的值都小于根结点的值
* 若右子树不为空，则所有右子树的值都大于根结点的值
* 左右子树都满足BST树的性质
* 中序遍历后，是有序数组，因此查找值时，**具有二分的性质**



#### 相关操作

##### 查找

根据BST树的性质，BST树的查找方式类似于**二分查找**，查找次数与树的深度有关，因此平均时间复杂度为$O(log_2N)$

```cpp
// 递归版
TreeNode* BSTSearch(TreeNode* root, int target) {
    if (root->val == target) return root;
    else if (root->val > target) return BSTSearch(root->left, target);
    else return BSTSearch(root->right, target);
    return NULL;
}

// 迭代版
TreeNode* BSTSearch(TreeNode* root, int target) {
    while (root) {
        if (root->val == target) return root;
        else if (root->val > target) root = root->left;
        else root = root->right;
    }
    return NULL;
}
```



##### 插入

* 插入也是基于查找实现的，若根结点的值等于待插入值则返回表示存在

* 若根结点值大于待插入值则向左子树查询
* 左子树为空，说明找到插入位置，将待插入值插入
* 左子树不为空，则向左子树查找
* 若根结点值小于待插入值则向右子树查询
* 右子树为空，说明找到插入位置，将待插入值插入
* 右子树不为空，则向右子树查找

```cpp
// root是根结点 node表示待插入结点
// 递归版
void BSTInsert(TreeNode* root, TreeNode* node) {
    if (root == nullptr || root->val == node->val) return;
    if (root->val > node->val) {
        if (root->left) BSTInsert(root->left, node);
        else root->left = node;
    } else {
        if (root->right) BSTInsert(root->right, node);
        else root->right = node;
    } 
}

// 迭代版
void BSTInsert(TreeNode* root, TreeNode* node) {
    while (root && root->val != node->val) {
        if (root->val > node->val) {
            if (root->left) root = root->left;
            else root->left = node, root = node;        
        } else {
            if (root->right) root = root->right;
            else root->right = node, root = node;          
        }
    }
}
```



##### 删除

删除结点还需要考虑怎么接上将待删除结点的左右子树接上，因此大致删除有三种情况

1. 待删除结点无孩子结点
2. 待删除结点只有一个孩子结点

3. 待删除结点有两个孩子结点

第一种情况

红色为待删除结点，该结点为叶子结点，找到直接删除即可

![](https://upload-images.jianshu.io/upload_images/9738807-3198aaba4a6ddbc6.png?imageMogr2/auto-orient/strip|imageView2/2/w/169/format/webp)

第二种情况 

待删除结点只有一个孩子结点时，只需要将结点5右孩子结点指向6，删除结点7即可



![](https://upload-images.jianshu.io/upload_images/9738807-cbf680f5701e2644.png?imageMogr2/auto-orient/strip|imageView2/2/w/169/format/webp)



第三种情况

待删除结点有两个孩子结点，我们的思路是从待删除结点中找到一个值来替代结点，并删除替代结点，这个过程还需要保持BST树原来的性质

我们可以找**待删除结点**中**左子树中值最大的结点**，或者**右子树中值最小的结点**作为替代结点

而找该替代结点后的删除结点的工作便是我们之前分析的情况1和情况2中的一种



![](https://upload-images.jianshu.io/upload_images/9738807-6304a0221a05d3c7.png?imageMogr2/auto-orient/strip|imageView2/2/w/327/format/webp)



```cpp
// 递归版
TreeNode* BSTDelete(TreeNode* root, int val) {
    if (root == nullptr) return NULL;
    if(root->val > val) root->left = BSTDelete(root->left, val);
    else if (root->val < val) root->right = BSTDelete(root->right, val);
    else {
        if (root->left && root->right) {					    // 情况3
            TreeNode* target = root->left;						// 找左子树最大
            while (target->right) target = target->right;
            root = BSTDelete(root, target->val);
            root->val = target->val;
        } else {												// 情况1和2
            if (root->left) root = root->left;					
            else root = root->right;
        }
    }
    return root;
}

```





[参考资料：二叉搜索树](https://www.jianshu.com/p/ff4b93b088eb)

[浙江大学数据结构二叉搜索树部分](https://www.icourse163.org/learn/ZJU-93001#/learn/announce)



### AVL树

> 平衡二叉搜索树(BBST)的一种



#### 性质

1. 是一颗二叉搜索树
2. 左右子树高度差的绝对值（平衡因子）最多为1，是严格平衡的二叉树



#### 相关操作

数据结构设计

```cpp
public class TreeNode {
    private int val;
    public TreeNode left;
    public TreeNode right;
    public int high;
    // 获取平衡因子
	private int getBalanceFactor(Node node);
    // 判断树是否为二叉搜索树
    public boolean isBalanced();
    // 获取结点高度
    private int getHeight(Node node);
    // 获取结点的平衡因子
    private int getBalanceFactor(Node node);
}
```



**插入**

LL（右旋）

LL表示向左子树的左孩子插入新结点后不平衡，这时候需要右旋操作

![](https://img-blog.csdnimg.cn/20190408211619425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MzQzNTU3,size_16,color_FFFFFF,t_70)





RR（左旋）

![](https://img-blog.csdnimg.cn/20190408214353545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MzQzNTU3,size_16,color_FFFFFF,t_70)



LR

![](https://img-blog.csdnimg.cn/20190408220207905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MzQzNTU3,size_16,color_FFFFFF,t_70)

第三个图x、z反了



RL

![](https://img-blog.csdnimg.cn/20190408215508810.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MzQzNTU3,size_16,color_FFFFFF,t_70)





**核心操作**

```java
// 左旋
int leftRotate(int u) {
    int v = node[u].rr;
    int t = node[v].ll;
    node[v].ll = u;
    node[u].rr = t;
    update(u);
    update(v);
    return v;
}

// 右旋
int rightRotate(int u) {
    int v = node[u].ll;
    int t = node[v].rr;
    node[v].rr = u;
    node[u].ll = t;
    update(u);
    update(v);
    return v;
}
```



[详细图文——AVL树](https://blog.csdn.net/qq_25343557/article/details/89110319)



### 红黑树

结点包含5个域：color、key、left、right、p，其中如果某结点没有一个子结点或者父结点，则指针域p为NIL值，这个指针域看作是红黑树的叶子结点

#### 性质

1. 符合二叉搜索树的性质
2. 结点为红色或者黑色
3. 根结点为黑色
4. 叶子结点（NIL）为黑色
5. 红色结点不连续
6. 从任意结点到其每个叶子结点的所有路径都包含相同数目的黑色结点

![](https://upload-images.jianshu.io/upload_images/2392382-4996bbfb4017a3b2.png?imageMogr2/auto-orient/strip|imageView2/2/w/526/format/webp)

<center>一颗简单的红黑树</center>

红黑树的本质：2-3-4树（即4阶的多路平衡查找树），2-3-4树可以对应多颗红黑树，而这些红黑树对应唯一的2-3-4树

**制定从2-3-4树转化为红黑树的规则**

2结点：为黑色结点

3结点：无论左倾还是右倾都是“上黑下红”

4结点：中间结点作为根结点，上黑下红

还有一种中间状态：4结点的裂变状态（选择中间的点作为黑色根结点，进行裂变操作得到了2结点和3结点）



一颗有n个内结点的红黑树高度至多为$2lg(n + 1)$

证明：每个内结点至少包含一个黑色结点，即2-3-4树的每一层都有一个结点，2-3-4树转换为红黑树，每个结点最多拓展为两层，设h为红黑树的高度，则对应的2-3-4高度至少为$h/2$，所以$ n >= 2^{h/2} - 1$







**插入操作**

原则

* 按二叉搜索树的方法，找到插入的点，对应多路平衡树查找树实质就是在叶子结点上插入结点
* 每次插入红色结点（若插入黑色结点会直接违反性质6，而插入红色结点可能违反性质5但是可以变色处理）
* 进行自平衡（左旋、右旋、变色）操作

分类讨论

* 插入的结点为根结点，红色变黑色
* 对应2结点
  * 父结点为黑色，则直接插入，不需要变色
* 对应3结点（可插入3个地方，3结点存在左倾和右倾，所以一共6种情况）
  * 左倾情况下，父结点为红色，叔叔结点为NIL结点（黑色结点），爷爷结点为黑色，插入结点**小于**父结点，此时以爷爷结点为支点进行右旋操作，然后父结点到了爷爷结点位置上变成黑色，爷爷结点变成红色
  * 左倾情况下，父结点为红色，叔叔结点为NIL结点（黑色结点），爷爷结点为黑色，插入结点**大于**父结点，此时以先以父结点为支点进行左旋操作，插入的结点到达了父结点的位置上，然后以爷爷结点进行右旋操作，插入结点到了爷爷结点位置上变成黑色，爷爷结点变成红色
  * 左倾情况下，父结点为黑色，兄弟结点为红色，直接插入，不用调整
  * 右倾情况下，父结点为红色，叔叔结点为NIL结点（黑色结点），爷爷结点为黑色，插入结点大于父结点，此时以爷爷结点为支点进行左旋操作，然后父结点到了爷爷结点的位置上变成黑色，爷爷结点变成红色
  * 右倾情况下，父结点为红色，叔叔结点为NIL结点（黑色结点），爷爷结点为黑色，插入结点小于父结点，此时以父结点为支点进行右旋操作，然后插入结点到达了父结点的位置上，然后以爷爷结点进行左旋操作，插入结点到了爷爷结点的位置上变成黑色，爷爷结点变成红色
  * 右倾情况下，父结点为黑色，兄弟结点为红色，直接插入，不用调整
* 对应4结点（可插入4个地方）一定是父结点和叔叔结点为红色，爷爷结点为黑色，需要裂变
  * 插入结点后，父结点和叔叔结点变成黑色，爷爷结点变成红色





**删除操作**

同二叉搜索树删除类似，叶子结点直接删除，非叶子结点的单孩子结点直接用孩子来替代，非叶子结点的双孩子结点找到前驱（后驱）结点来替代，然后转化前两种删除情况即可然后进行自平衡操作

由B树的分裂性质可知，除根结点外，B树的每个结点都有父结点和兄弟节点，那么2-3-4树的结点也具有这样的性质，也即**红黑树非叶子结点一定有两个子树**

1. 删除结点为根结点，直接删除
2. 待删除结点只有一个儿子结点
   * 待删除结点为红色，直接删除
   * 待删除结点为黑色，儿子结点变黑，替代待删除结点
3. 待删除结点无儿子结点且为红色，直接删除
4. 待删除结点为黑色，**兄弟结点为父结点的右孩子**
   1. 父结点为红色，兄弟结点为黑色，父结点变黑，以父结点为支点左旋，此时整颗红黑树平衡
   2. 父结点为黑色，兄弟结点为黑色（原则为兄弟结点有红色孩子则可以借，借的时候父亲下来帮忙，兄弟结点上去，否则兄弟结点就自损变红，继续向上调整）
      1. 兄弟结点的两个子结点为黑，兄弟结点自损变红，以父结点为根结点的红黑树平衡，从父结点开始进行步骤4或者5
      2. 兄弟结点的左孩子sl为任意颜色，右孩子sr为红色结点，右孩子变黑，以父结点为支点左旋，就完成了平衡
      3. 兄弟结点的左孩子sl为红色，右孩子sr为黑色，兄弟结点变红，兄弟结点的左孩子变黑，以兄弟结点为支点右旋，兄弟结点变为sl然后进行进行步骤4.2.2
   3. 父结点为黑色，兄弟结点为红色，兄弟结点变黑，父结点变红，以父结点为支点左旋，将父结点设置为原来的兄弟结点，此时兄弟结点一定为黑色，进行步骤4.2
5. 待删除结点为黑色，**兄弟结点为父结点的左孩子**
   1. 父结点为红色，兄弟结点为黑色，父结点变黑，以父结点为支点右旋，此时整颗红黑树平衡
   2. 父结点为黑色，兄弟结点为黑色
      1. 兄弟结点的两个子结点为黑色，兄弟结点自损变红，以父节点的根结点的红黑树平衡，从父结点开始进行步骤4或者5
      2. 兄弟结点的左孩子sl为红色，右孩子sr为任意颜色，左孩子sl变黑，以父结点为支点右旋，整颗红黑树平衡
      3. 兄弟结点的左孩子sl为黑色，右孩子sr为红色，兄弟结点变红，右孩子sr变黑，以兄弟结点为支点左旋，兄弟结点变成了sr然后执行步骤5.2.2
   3. 父结点为黑色，兄弟结点为红色，父结点变红，兄弟结点变黑，以父结点为支点右旋，父结点设置为原来的兄弟结点，此时当前的兄弟结点一定为黑色，进行步骤5.2





[30张图带你彻底理解红黑树](https://www.jianshu.com/p/e136ec79235c)

[优质视频](https://www.bilibili.com/video/BV135411h7wJ)

[红黑树在线演示](https://rbtree.phpisfuture.com/)

### B树/B+树

是一颗m阶的多路平衡查找树，即一个结点最多有m个孩子结点，能存放m-1个关键字

B树性质

1. 每个结点最多有m-1个关键字
2. 根结点最少有1个关键字
3. 每个结点的关键字按从小到大排序
4. 所有的叶子结点位于同一层，即根结点到叶子结点长度相同



B+树性质

1. 拥有B树的性质
2. 内部结点（也称为索引结点）关键字不存储数据
3. 叶子结点存储数据，且相邻的叶子结点有指针，指针指向相邻的叶子结点



[B树详解](https://www.cnblogs.com/nullzx/p/8729425.html)







### 相关习题(有亿点点多...)

| 题目链接                                                     | 说明                                 |
| ------------------------------------------------------------ | ------------------------------------ |
| [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/) | 前序遍历模板                         |
| [589. N叉树的前序遍历](https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/) | 前序遍历拓展                         |
| [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/) | 中序遍历模板                         |
| [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/) | 后序遍历模板                         |
| [590. N叉树的后序遍历](https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/) | 后序遍历拓展                         |
| [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/) | 层序遍历模板                         |
| [107. 二叉树的层次遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/) | 层序遍历模板变形                     |
| [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/) | 层序遍历拓展                         |
| [429. N叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/) | 层序遍历拓展                         |
| [103. 二叉树的锯齿形层次遍历](https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/) | 层序遍历拓展                         |
| [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/) | 层序遍历拓展                         |
| [100. 相同的树](https://leetcode-cn.com/problems/same-tree/) | 递归判断                             |
| [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) | 递归判断                             |
| [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/) | 递归判断                             |
| [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/) | 递归记录最大深度                     |
| [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/) | 递归记录到叶子结点的最少结点数       |
| [559. N叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/) | 递归，叶子结点比较最大深度           |
| [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/) | 递归，找左右子树最大深度             |
| [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/) | 层序遍历变形题                       |
| [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/) | 递归求左右子树最长的路径             |
| [129. 求根到叶子节点数字之和](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/) | 遍历变形                             |
| [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/) | 递归终点为叶子结点模板               |
| [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)  | 递归终点为叶子结点模板               |
| [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/) | 递归终点为叶子结点模板               |
| [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/) | 递归套递归                           |
| [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/) | 递归求左右子树最大路径和             |
| [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/) | 遍历模板                             |
| [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/) | 遍历模板                             |
| [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/) | 二叉搜索树搜索模板                   |
| [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/) | 二叉搜索树删除模板                   |
| [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/) | 二叉搜索树插入模板                   |
| [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/) | 基于分治思想，构造二叉搜索树         |
| [1382. 将二叉搜索树变平衡](https://leetcode-cn.com/problems/balance-a-binary-search-tree/) | 构造平衡的二叉搜索树                 |
| [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/) | 了解卡特兰数                         |
| [95. 不同的二叉搜索树 II](https://leetcode-cn.com/problems/unique-binary-search-trees-ii/) | 基于分治思想枚举所有二叉搜索树       |
| [230. 二叉搜索树中第K小的元素](https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/) | 中序遍历模板                         |
| [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/) | 根据二叉搜索树的性质                 |
| [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/) | 后序遍历                             |
| [173. 二叉搜索树迭代器](https://leetcode-cn.com/problems/binary-search-tree-iterator/) | 迭代中序遍历，平摊的时间复杂度为O(1) |
| [297. 二叉树的序列化与反序列化](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/) | 遍历+字符串构造二叉树                |
| [449. 序列化和反序列化二叉搜索树](https://leetcode-cn.com/problems/serialize-and-deserialize-bst/) | 理解压缩编码思想即可                 |
| [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/) | 找根再分治处理                       |
| [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/) | 找根再分治处理                       |







## 堆

> 堆(heap)经常用于实现优先队列(priority queue)即每次从队列取出来的都是优先级最高的元素



### 性质

1. 堆是一个完全二叉树

2. 堆的两个子堆也满足堆的性质

3. 大根堆根上为最大元素，小根堆根上为最小元素
4. 参考本篇二叉树的性质5

堆一般采用静态数组来实现

### 模板

```cpp
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的值在堆中的位置
// hp[k]存储堆中下标是k的值是第几个插入的
int h[N], ph[N], hp[N], sz;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

// 向下调整
void down(int u) {
    int t = u;
    if (2 * u <= sz && h[t] > h[2 * u]) t = 2 * u;
    if (2 * u + 1 <= sz && h[t] > h[2 * u + 1]) t = 2 * u + 1;
    if (t != u) {
        heap_swap(t, u);
        down(t);
    }
}

// 向上调整
void up(int u) {
    while (u >> 1 && h[u] < h[u >> 1]) {
        heap_swap(u, u >> 1);
        u >>= 1;
    }
}

// 建堆O(N)
for (int i = n / 2; i; i -- ) down(i);
```







### STL常用方法

```cpp
// 默认大根堆
priority_queue<int, vector<int>>
// 小根堆
priority_queue<int, vector<int>, greater<int>>

// 方法同queue
top 访问堆顶元素
empty 判断是否为空
size 返回堆的元素个数
push 插入元素同时维护堆的性质
pop 弹出堆顶元素同时维护堆的性质

    
```









### 相关习题

| 题目链接                                                     | 说明                                |
| ------------------------------------------------------------ | ----------------------------------- |
| [838. 堆排序](https://www.acwing.com/problem/content/840/)   | 需要注意建堆方式                    |
| [839. 模拟堆](https://www.acwing.com/problem/content/841/)   | 需要维护第k个插入的数及其在堆的下标 |
| [148. 合并果子](https://www.acwing.com/problem/content/150/) | 贪心+堆                             |
| [145. 超市](https://www.acwing.com/problem/content/147/)     | 贪心+堆                             |
| [146. 序列](https://www.acwing.com/problem/content/148/)     | 两路归并思想+堆                     |





## 并查集

### 作用

1. 将两个集合合并
2. 判断元素属于哪个集合





### 并查集的相关操作

1. 初始化数组（代表每个结点的父结点）将每一个结点的父结点设置为自己表示为根结点，即p[i] = i
2. 查找元素所属的集合（find），则不断利用数组p寻找父结点直到p[i] = i，即while (p[i] != i) find(p[i])
3. 合并两个集合操作（union），找到两个集合的根结点，将一个结点的父结点设置成另一个结点





### 并查集优化

1. 按秩归并：基本思路是将较少结点的根结点指向包含较多的根结点

   

2. 路径压缩：在进行find操作时同时将所有子结点的根结点设置为该集合的根结点，减少了子结点到根结点的距离



### 并查集模板

```cpp
// 初始化
for (int i = 1; i <= n; i++) p[i] = i;

// find(x) 表示查找结点x所在集合的根结点
int find(int x) {
    if (x == p[x]) return x;
    return p[x] = find(p[x]);
}

// 将集合a合并到集合b
p[find(a)] = find(b)
    
// 带权并查集find版本
int find(int x) {
    if (x == p[x]) return x;
    int t = find(p[x]);
    dist[x] += dist[p[x]];
    return p[x] = t;
}    
```





### 相关习题

| 题目链接                                                     | 说明                               |
| ------------------------------------------------------------ | ---------------------------------- |
| [836. 合并集合](https://www.acwing.com/problem/content/838/) | 并查集模板                         |
| [1249. 亲戚](https://www.acwing.com/problem/content/1251/)   | 并查集裸题，注意输入输出           |
| [837. 连通块中点的数量](https://www.acwing.com/problem/content/839/) | 维护连通块点的数量                 |
| [1250. 格子游戏](https://www.acwing.com/problem/content/1252/) | 判断环问题                         |
| [517. 信息传递](https://www.acwing.com/problem/content/519/) | 求最小环                           |
| [914. 樱桃网](https://www.acwing.com/problem/content/916/)   | 最小生成树                         |
| [237. 程序自动分析](https://www.acwing.com/problem/content/239/) | 维护相等的集合                     |
| [238. 银河英雄传说](https://www.acwing.com/problem/content/240/) | 维护结点到根节点的距离和集合的大小 |
| [239. 奇偶游戏](https://www.acwing.com/problem/content/241/) | 用来维护前缀和与根节点的奇偶性关系 |
| [240. 食物链](https://www.acwing.com/problem/content/242/)   | 维护结点到根节点的距离             |
| [257. 关押罪犯](https://www.acwing.com/problem/content/259/) | 贪心+带权并查集                    |
| [258. 石头剪子布](https://www.acwing.com/problem/content/260/) | 枚举某个人为裁判+带权并查集        |
| [784. 强盗团伙](https://www.acwing.com/problem/content/description/786/) | 合并同一活的强盗                   |
| [1242. 修改数组](https://www.acwing.com/problem/content/1244/) | 集合根节点维护没用过的数           |



## 字符串



### KMP

[参考：从头到尾彻底理解KMP](https://www.cnblogs.com/zhangtianq/p/5839909.html)





### STL常用方法

```cpp

```



## 字典树

### Trie

```cpp
int son[N][26], cnt[N], inx;
// 0号点既是根结点，又是空结点
// son[][]存储树中每个结点的子结点
// cnt[]存储以每个结点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ inx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```



### 相关习题

| 题目链接                                                     | 说明             |
| ------------------------------------------------------------ | ---------------- |
| [835. Trie字符串统计](https://www.acwing.com/problem/content/837/) | 模板题           |
| [142. 前缀统计](https://www.acwing.com/problem/content/144/) | 模板题           |
| [143. 最大异或对](https://www.acwing.com/problem/content/145/) | Trie树存二进制数 |
| [144. 最长异或值路径](https://www.acwing.com/problem/content/146/) | 上题拓展         |
| [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/) | 链表建立Trie     |
| [648. 单词替换](https://leetcode-cn.com/problems/replace-words/) | 模板简单应用     |





## 哈希表

### 概念

哈希表是用于查找的数据结构，它通过值映射关键字的方式，然后通过关键字来实现高效的查找，哈希表的平均查找时间复杂度为O（1），是一种查找高效的数据结构，哈希表的设计有两个主要的问题，第一个是哈希函数的设计，第二个是哈希冲突以及解决办法



**哈希函数设计**

哈希函数的设计原则

1. 计算简单高效，保证了哈希表的高效
2. 计算出来的关键字随机且均匀，减少了哈希冲突碰撞

常用的哈希函数有折叠法（将数字分成几个部分然后取叠加和作为关键字）、平方取中法（对每个值进行平方然后取中间的若干个位）、数字分析法（通过分析数据的分布规律提取分布均匀的若干位作为关键字）、随机法、除法散列法（用的最多的一种，H（key）=key MOD p （p<=m m为表长）关键在于p的选取）、乘法散列法



**哈希冲突**

哈希冲突即不同的值产生的关键字相同，解决哈希冲突的办法有，开放定址法、链地址法、再哈希法



**开放定址法**

采用的基本思路就是当冲突时，利用某种方法计算增量的形式重新确定哈希函数$$ H = (H(key) + d_i) MOD m $$其中m为表长

1. 线性探测法
2. 平方探测法
3. 双重探测法



**链地址法**

用的最多的一种，HashMap用的就是链地址法，采用链表的方式将冲突的数据组织起来



**负载因子**

负载因子表示了哈希表空间元素的密度，越大说明哈希表越慢，产生冲突的可能性越大，一般0.75为合适的负载因子，大了需要扩容



### STL常用方法

```cpp
// unordered_map
#include<unordered_map>    // 头文件
unordered_map<int, int> ma // 定义
ma[1] = 2				   // 插入
ma[1]                      // 查询
ma.count(1)                // 查询key是否存在，存在则为true

for (auto &item : ma) {    // 遍历
    cout << item.first << ' ' << item.second << endl;
}
```







## 位运算、递推、快速幂

### 位运算

应用：只要用二进制就需要使用位运算进行操作，而二进制的常见应用是用来表示某个状态。这类状态压缩问题因此需要用位运算，对于树状数组的lowbit函数也是对位运算的应用。

```cpp
// 位移
>>表示二进制右移一位
<<表示二进制左移一位
// 与
a&1用来取二进制下a最低位的值
// 或
// 非
常用于取反
// 异或
    
// lowbit取最后1位1
x&-x
```





### 快速幂

用法：快速幂用来加速求解$a^b$ ，算法的基本思想是倍增。



**基本思路**：以$5^5$为例，

1. 将指数以二进制的方式展开得到101B
2. 根据二进制能够拼凑出任意整数的性质和整数幂运算规则，因此我们可以写出$5^{101B} = 5^{100B} * 5^{001B}$
3. 这个展开式启发我们可以利用二进制的性质来加速$a^b$ 的运算

**步骤：**

1. 初始化base = 底数，base指当前位权
2. 每次取b的二进制下的最低位，b&1 == 1说明该位下可以乘以当前位权base
3. b右移1位，位权因此变大，base更新为base的平方，重复第2步直到b为0



**快速幂模板**

```cpp
// m^k%p
int qmi(int m, int k, int p)
{
    int res = 1 % p, base = m;
    while (k)
    {
        if (k&1) res = res * base % p;
        base = base * base % p;
        k >>= 1;
    }
    return res;
}
```





矩阵快速幂顾名思义是用来加速计算矩阵$A$形如$A^b$这样的计算，常用于解决递推式计算超时的问题，将递推式通过拼凑的方式可将其转化成矩阵，最后用快速幂求解，难点在于找递推式以及如何通过递推式构造一个矩阵

以斐波那契的递推式$f_{n+2} = f_{n+1} + f_{n}$为例
$$
A*\left\{
 \begin{matrix}
   f_{n} \\
   f_{n+1} \\
  \end{matrix} 
\right\}=
\left\{
 \begin{matrix}
   f_{n+1} \\
   f_{n+2} \\
  \end{matrix} 
\right\}
$$

上式在于如何构造出一个A矩阵，构造出来后先求出矩阵$A$的n次方再乘以右式，那么结果就能得到递推n次后$f_n$的结果，时间复杂度由原来的$O(n)$变为了$O(logn)$!



### 相关习题

| 题目链接                                                     | 说明             |
| ------------------------------------------------------------ | ---------------- |
| [89. a^b](https://www.acwing.com/problem/content/91/)        | 快速幂模板题     |
| [90. 64位整数乘法](https://www.acwing.com/problem/content/92/) | 位运算处理乘法   |
| [95. 费解的开关](https://www.acwing.com/problem/content/97/) | 递推+枚举+位运算 |
| [116. 飞行员兄弟](https://www.acwing.com/problem/content/118/) | 枚举+位运算      |
| [1208. 翻硬币](https://www.acwing.com/problem/content/1210/) | 递推             |
| [1303. 斐波那契前 n 项和](https://www.acwing.com/problem/content/1305/) |                  |
| [1217. 垒骰子](https://www.acwing.com/problem/content/1219/) |                  |
| [1455. 招聘](https://www.acwing.com/problem/content/1457/)   | 约瑟夫环问题     |







## 搜索



### BFS模板

```cpp
queue<int> q;
st[start] = true; // 表示start已经被遍历过
q.push(start);
int cnt = 0;
while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])			// 遍历t的相邻的点
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; 							// 表示点j已经被遍历过
            q.push(j);
        }
    }
    cnt++;											// 当前层遍历完毕
}
```





### DFS模板

```cpp
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}


// IDA*模板, 其中f为评估函数，表示最少需要多少层才满足解

bool dfs(int u, int max_depth) {
    if (f() + u > max_depth) return false;
    if (check()) return true;
    for (各种操作) {
        // 决策
        if(dfs(u + 1, max_depth)) return true;
        // 恢复现场        
    }

    return false;
}

int main() {
    int depth = 0;
    while (!dfs(0, depth)) depth++;
    cout << depth << endl;
    return 0;
}
```



### 搜索优化技巧

1. 优化搜索顺序：优先搜索分枝少的结点
2. 排除等效冗余：与顺序无关的搜索采用组合型进行搜索
3. 可行性剪枝：当前条件一定合法则可以排除
4. 最优性剪枝：当前解大于当前最优解则一定不满足最优解
5. 记忆化搜索（dp）







### 相关习题

| 题目链接                                                     | 说明                       |
| ------------------------------------------------------------ | -------------------------- |
| [92. 递归实现指数型枚举](https://www.acwing.com/problem/content/94/) | 枚举子集                   |
| [93. 递归实现组合型枚举](https://www.acwing.com/problem/content/95/) | 组合类型枚举               |
| [94. 递归实现排列型枚举](https://www.acwing.com/problem/content/96/) | 全排列                     |
| [96. 奇怪的汉诺塔](https://www.acwing.com/problem/content/98/) | 汉诺塔问题                 |
| [1209. 带分数](https://www.acwing.com/problem/content/1211/) | next_permutation的应用     |
| [843. n-皇后问题](https://www.acwing.com/problem/content/845/) | 简单回溯+剪枝              |
| [846. 树的重心](https://www.acwing.com/problem/content/848/) | 树形dp思想                 |
| [1112. 迷宫](https://www.acwing.com/problem/content/1114/)   | 简单dfs                    |
| [1113. 红与黑](https://www.acwing.com/problem/content/1115/) | 简单dfs                    |
| [1116. 马走日](https://www.acwing.com/problem/content/1118/) | 简单dfs                    |
| [1117. 单词接龙](https://www.acwing.com/problem/content/1119/) | 字符串处理+简单dfs         |
| [1118. 分成互质组](https://www.acwing.com/problem/content/1120/) | 判断质数+搜索              |
| [165. 小猫爬山](https://www.acwing.com/problem/content/167/) | 剪枝                       |
| [166. 数独](https://www.acwing.com/problem/content/168/)     | 位运算优化                 |
| [167. 木棒](https://www.acwing.com/problem/content/description/169/) | 剪枝优化                   |
| [170. 加成序列](https://www.acwing.com/problem/content/172/) | 迭代加深                   |
| [171. 送礼物](https://www.acwing.com/problem/content/173/)   | 双向dfs                    |
| [180. 排书](https://www.acwing.com/problem/content/182/)     | IDA*                       |
| [181. 回转游戏](https://www.acwing.com/problem/content/183/) | IDA*                       |
| [184. 虫食算](https://www.acwing.com/problem/content/186/)   | 剪枝                       |
| [183. 靶形数独](https://www.acwing.com/problem/content/185/) | 数独变形题                 |
| [1225. 正则问题](https://www.acwing.com/problem/content/description/1227/) | 运算符与递归               |
| [1243. 糖果](https://www.acwing.com/problem/content/description/1245/) | IDA*                       |
| [844. 走迷宫](https://www.acwing.com/problem/content/846/)   | 简单bfs                    |
| [1097. 池塘计数](https://www.acwing.com/problem/content/1099/) | bfs求连通块数量            |
| [1233. 全球变暖](https://www.acwing.com/problem/content/1235/) | 蓝桥杯真题                 |
| [189. 乳草的入侵](https://www.acwing.com/problem/content/description/191/) | 读入有毒                   |
| [1098. 城堡问题](https://www.acwing.com/problem/content/1100/) | 状态压缩                   |
| [1106. 山峰和山谷](https://www.acwing.com/problem/content/description/1108/) | dfs判断山峰与山谷          |
| [1076. 迷宫问题](https://www.acwing.com/problem/content/1078/) | 简单bfs+输出路径           |
| [188. 武士风度的牛](https://www.acwing.com/problem/content/190/) | 简单bfs                    |
| [1100. 抓住那头牛](https://www.acwing.com/problem/content/1102/) | bfs最短路模型              |
| [173. 矩阵距离](https://www.acwing.com/problem/content/175/) | 多起点bfs最短路模型        |
| [845. 八数码](https://www.acwing.com/problem/content/description/847/) | 存储状态bfs模型            |
| [1107. 魔板](https://www.acwing.com/problem/content/1109/)   | 存储状态bfs模型+记录最短路 |
| [1131. 拯救大兵瑞恩](https://www.acwing.com/problem/content/1133/) | 状态压缩+最短路问题        |











## 图论

### 基本概念及术语

* 顶点(vertex)
* 弧(arc)：也叫边
* 权值
* 有向图
* 无向图
* 稀疏图：|E|接近|V|
* 稠密图：|E|接近|V|²
* 出度：顶点出边数量
* 入度：顶点入边数量
* 路径：一个顶点到另一个顶点经过的各顶点
* 简单路径：路径上各顶点均不互相重复
* 回路：路径中第一个顶点与最后一个顶点重合
* 欧拉通路：图G一个路径上每一条边都恰好经过一次
* 欧拉回路：存在欧拉通路是回路
* 欧拉图：图G存在欧拉回路
* 基图：有向图忽略图中所有边的方向，得到的无向图称为有向图的基图
* 连通图：图中所有的点均能到达其它所有的点
* 连通分量：子图中任意两点u、v都有回路
* 强连通分量：极大连通分量
* 强连通图：图中任意两点相互可达
* 割点：无向连通图中，去掉一个点以及它相邻的边，图的连通块个数增加，则该点为割点
* 桥（割边）：无向连通图中，去掉一条边，图的连通块个数增加，则该边为割边
* 点双连通分量：极大的点双连通图
* 边双连通分量：极大的边双连通图
* 二分图：顶点能分成两个集合，并且图中每条边的两个顶点分属不同集合上的点
* 最大匹配：二分图子图M中，任意两条边都不依附同一个顶点的最多边数
* 最小覆盖点：选取最少的点，覆盖住所有边
* 最大独立集：选择最多的点，使得任意两点都不相连





### 建图方式

#### 邻接矩阵

```cpp
// 结点数为N
int g[N][N];
// 其中g[i][j]表示结点i到结点j的边权，g[i][j]为0表示无边
```



#### 邻接表

```cpp
// 方法1，使用静态数组，对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], w[N], inx;

// 添加一条边a->b,边权为c
void add(int a, int b, int c)
{
    w[inx] = c, e[inx] = b, ne[idx] = h[a], h[a] = inx++ ;
}

// 初始化
inx = 0;
memset(h, -1, sizeof h);



// 方法2，使用vector
typedef pair<int, int> PII;
vector<PII> h(N);
// 添加一条边a->b,边权为c
h[a].push_back({b,c});

```



### 最短路算法



#### Dijkstra算法

**时间复杂度为**$O(n^2)$**,适用于稠密图**

```cpp
// s表示源点，dist[j]表示源点到j的最短路
void dijkstra(int s) {
    memset(dist, 0x3f, sizeof dist);
    dist[s] = 0;
    
    for (int i = 1; i <= n; i++) {
        int t = -1;
        for (int j = 1; j <= n; j++) {
            if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j;
        }
        
        st[t] = 1;
        for (int j = 1; j <= n; j++) {
            if (dist[j] > dist[t] + g[t][j]) dist[j] = dist[t] + g[t][j];
        }
    }
    if (dist[n] == 0x3f3f3f3f) cout << "-1" << endl;
    else cout << dist[n] << endl;
}
```



#### Dijkstra算法优化版

**时间复杂度为**$O(mlogn)$**,其中n为点数，m为边数，适用于稀疏图**

```cpp
typedef pair<int, int> PII;

int n;      // 点的数量
int h[N], w[N], e[N], ne[N], inx;       // 邻接表存储所有边
int dist[N];        // 存储所有点到1号点的距离
bool st[N];     // 存储每个点的最短距离是否已确定

// 求1号点到n号点的最短距离，如果不存在，则返回-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // first存储距离，second存储结点编号

    while (heap.size())
    {
        auto t = heap.top();
        heap.pop();

        int ver = t.second, distance = t.first;

        if (st[ver]) continue;
        st[ver] = true;

        for (int i = h[ver]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > distance + w[i])
            {
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



#### SPFA

**平均时间复杂度为**$O(m)$**,最坏时间复杂度** $O(nm)$**,其中n为点数，m为边数,常用于求负权边**

```cpp
int n;      // 总点数
int h[N], w[N], e[N], ne[N], idx;       // 邻接表存储所有边
int dist[N];        // 存储每个点到1号点的最短距离
bool st[N];     // 存储每个点是否在队列中

// 求1号点到n号点的最短路距离，如果从1号点无法走到n号点则返回-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

    queue<int> q;
    q.push(1);
    st[1] = true;

    while (q.size())
    {
        auto t = q.front();
        q.pop();

        st[t] = false;

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                if (!st[j])     // 如果队列中已存在j，则不需要将j重复插入
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }

    if (dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}
```



#### Floyd算法

**时间复杂度为**$O(n^3)$**,其中n为点数**

```cpp
初始化：
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= n; j ++ )
            if (i == j) d[i][j] = 0;
            else d[i][j] = INF;

// 算法结束后，d[a][b]表示a到b的最短距离
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```



#### 相关习题

| 题目链接                                                     | 说明                         |
| ------------------------------------------------------------ | ---------------------------- |
| [849. Dijkstra求最短路 I](https://www.acwing.com/problem/content/851/) | 朴素版Dijkstra算法模板       |
| [850. Dijkstra求最短路 II](https://www.acwing.com/problem/content/852/) | 堆优化版Dijkstra算法模板     |
| [851. spfa求最短路](https://www.acwing.com/problem/content/853/) | spfa最短路算法模板           |
| [854. Floyd求最短路](https://www.acwing.com/problem/content/856/) | 多源最短路算法模板           |
| [1129. 热浪](https://www.acwing.com/problem/content/description/1131/) | 无向图最短路                 |
| [1128. 信使](https://www.acwing.com/problem/content/1130/)   | 理解dist[]数组的含义         |
| [1127. 香甜的黄油](https://www.acwing.com/problem/content/1129/) | 枚举源点                     |
| [1126. 最小花费](https://www.acwing.com/problem/content/1128/) | 乘法转化成最短路             |
| [920. 最优乘车](https://www.acwing.com/problem/content/922/) | 根据换乘次数建图             |
| [903. 昂贵的聘礼](https://www.acwing.com/problem/content/905/) | 建立虚拟结点                 |
| [1135. 新年好](https://www.acwing.com/problem/content/1137/) | 全排列+枚举思想              |
| [1125. 牛的旅行](https://www.acwing.com/problem/content/1127/) | floyd+枚举                   |
| [340. 通信线路](https://www.acwing.com/problem/content/342/) | 二分+最短路                  |
| [342. 道路与航线](https://www.acwing.com/problem/content/344/) | 拓扑排序+dijkstra            |
| [341. 最优贸易](https://www.acwing.com/problem/content/343/) | 需要理解最短路算法           |
| [1137. 选择最佳线路](https://www.acwing.com/problem/content/1139/) | 多个起点、多终点问题         |
| [1134. 最短路计数](https://www.acwing.com/problem/content/1136/) | dp思想求方案数               |
| [383. 观光](https://www.acwing.com/problem/content/385/)     | 求最短路和次短路及其条数模板 |





### 差分约束+负环









### 最小生成树

#### Prim算法

**时间复杂度为**$O(n^2)$**,适用于稠密图**

```cpp
int n;      		// n表示点数
int g[N][N];        // 邻接矩阵，存储所有边
int dist[N];        // 存储其他点到当前最小生成树的距离
bool st[N];     	// 存储每个点是否已经在生成树中


// 如果图不连通，则返回INF(值是0x3f3f3f3f), 否则返回最小生成树的树边权重之和
int prim()
{
    memset(dist, 0x3f, sizeof dist);
	dist[1] = 0;
    int res = 0;
    for (int i = 1; i <= n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j])) t = j;
        
		st[t] = true;
        if (dist[t] == INF) return INF;
		res += dist[t];

        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    }

    return res;
}
```





#### Kruskal算法

**时间复杂度为**$O(mlogm)$**,其中n为点数，m为边数，适用于稀疏图**

```cpp
int n, m;       // n是点数，m是边数
int p[N];       // 并查集的父结点数组

struct Edge     // 存储边
{
    int a, b, w;

    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];

int find(int x)     // 并查集
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int kruskal()
{
    sort(edges, edges + m);

    for (int i = 1; i <= n; i ++ ) p[i] = i;    // 初始化并查集

    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;

        a = find(a), b = find(b);
        if (a != b)     // 如果两个连通块不连通，则将这两个连通块合并
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }

    if (cnt < n - 1) return INF;
    return res;
}
```





#### 相关习题

| 题目链接                                                     | 说明            |
| ------------------------------------------------------------ | --------------- |
| [858. Prim算法](https://www.acwing.com/problem/content/860/) | 模板题          |
| [859. Kruskal算法](https://www.acwing.com/problem/content/861/) | 模板题          |
| [1140. 最短网络](https://www.acwing.com/problem/content/1142/) | 简单应用        |
| [1141. 局域网](https://www.acwing.com/problem/content/1143/) | 简单应用        |
| [1142. 繁忙的都市](https://www.acwing.com/problem/content/1144/) | 简单应用        |
| [1143. 联络员](https://www.acwing.com/problem/content/1145/) | 简单应用        |
| [1144. 连接格点](https://www.acwing.com/problem/content/1146/) | 二维转一维      |
| [1146. 新的开始](https://www.acwing.com/problem/content/1148/) | 建立超级源点    |
| [1145. 北极通讯网络](https://www.acwing.com/problem/content/1147/) | 贪心+最小生成树 |
| [346. 走廊泼水节](https://www.acwing.com/problem/content/348/) | 计数            |
| [1148. 秘密的牛奶运输](https://www.acwing.com/problem/content/1150/) | 次小生成树问题  |



### 拓扑排序

**作用**：用于求有向无环图的拓扑排序，即图若存在环则不存在拓扑排序，因此还能用来判断图是否有环

基本思路：

1. 记录每个边的入度情况

2. 将所有入度为0的结点加入队列
3. 基于BFS，遍历队头的结点，同时删除已经遍历过结点的所有出度边，更新所有点的入度边
4. 若更新的结点入度边为0则加入队列
5. 若存在拓扑排序则个数一定等于结点数



#### 模板

```cpp
// idg[i]表示结点i的入度数
bool topsort() {
    queue<int> q;
    for (int i = 1; i <= n; i++) if (!idg[i]) q.push(i);
    int cnt = 0;
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        st[t] = true;
        res[++cnt] = t;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (--idg[j] == 0) q.push(j);
        }
    }
    return cnt == n;
}
```



#### 相关习题

| 题目链接                                                     | 说明                         |
| ------------------------------------------------------------ | ---------------------------- |
| [848. 有向图的拓扑序列](https://www.acwing.com/problem/content/850/) | 模板题                       |
| [1191. 家谱树](https://www.acwing.com/problem/content/1193/) | 简单应用                     |
| [1192. 奖金](https://www.acwing.com/problem/content/1194/)   | 简单应用                     |
| [164. 可达性统计](https://www.acwing.com/problem/content/166/) | 简单应用                     |
| [P1113 杂务](https://www.luogu.com.cn/problem/P1113)         | 拓扑排序+dp思想              |
| [P4017 最大食物链计数](https://www.luogu.com.cn/problem/P4017) | 拓扑排序+dp思想              |
| [P1807 最长路](https://www.luogu.com.cn/problem/P1807)       | 拓扑排序+dp思想              |
| [P1347 排序](https://www.luogu.com.cn/problem/P1347)         | 拓扑排序                     |
| [456. 车站分级](https://www.acwing.com/problem/content/458/) | 虚拟点+差分约束思想+拓扑排序 |



### 二分图

二分图主要应用有判断二分图（染色法），以及求二分图的最大匹配数（匈牙利算法）



**二分图的重要结论**

1. 最大匹配数 = 最小点覆盖数 = 最大独立集数 - 结点数

#### 染色法

**时间复杂度为**$O(n + m)$**,其中n为点数，m为边数**

```cpp
int n;      					// n表示点数
int h[N], e[M], ne[M], inx;     // 邻接表存储图
int color[N];       			// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色

// 参数：u表示当前结点，c表示当前点的颜色
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }

    return true;
}

bool check()
{
    memset(color, -1, sizeof color);
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0)) return false;
    return true;
}
```





#### 匈牙利算法

**时间复杂度为**$O(nm)$**,其中n为点数，m为边数**

```cpp
int n1, n2, m;			// n1、n2分别属于两个点集1、2
int st[N], match[N];	// match[i]表示点集1中的点i匹配到的点集2的点， st[i]表示点集1的点i是否有匹配
bool find(int u) {
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!st[j]) {
            st[j] = true;
            if (!match[j] || find(match[j])) {
                match[j] = u;
                return true;
            }
        }
    }
    return false;
}

int res = 0;

for (int i = 1; i <= n1; i++) {
    memset(st, 0, sizeof st);
    if (find(i)) res++;
}
    
```



#### 相关习题

| 题目链接                                                     | 说明                 |
| ------------------------------------------------------------ | -------------------- |
| [860. 染色法判定二分图](https://www.acwing.com/problem/content/862/) | 模板题               |
| [861. 二分图的最大匹配](https://www.acwing.com/problem/content/863/) | 模板题               |
| [257. 关押罪犯](https://www.acwing.com/problem/content/259/) | 二分+判断二分图      |
| [372. 棋盘覆盖](https://www.acwing.com/problem/content/374/) | 二分图的最大匹配问题 |
| [376. 机器任务](https://www.acwing.com/problem/content/378/) | 最小点覆盖问题       |
| [378. 骑士放置](https://www.acwing.com/problem/content/380/) | 最大独立集           |



### 树的直径与LCA

#### 树的直径

##### 两遍dfs

思路：第一遍dfs找距离根结点最远的结点u（一定是叶子结点），第二遍从叶子结点u开始dfs找距离结点u的最远结点v（一定是叶子结点），则u到v的路径一定是树的直径

```cpp
void dfs(int u, int fa, int val) {
    d[u] = val;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (j != fa) dfs(j, u, val + w[i]);
    }
}
int u = 1;
dfs(1, -1, 0);
for (int i = 1; i <= n; i++)
    if (d[i] > d[u]) u = i;

dfs(u, -1, 0);
for (int i = 1; i <= n; i++)
    if (d[i] > d[u]) u = i;
// 最后找到的dist[u]即为树的直径
```



##### 树形dp

思路：以当前结点为根结点，从孩子结点找到最长路径d1和次最长路径d2，则经过该根结点的最长路径一定为d1+d2，向其父结点返回d1，dfs完毕后遍历每个结点，寻找以每个结点为根结点的最长路径，最大值即为树的直径，定义$f(u)$为以u为根结点的最长路径，则状态转移方程有
$$
f(u) = d1{f(son1)} + d2{f(son2)}
$$

```cpp
int dfs(int u, int fa) {
    int d1 = 0, d2 = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (j != fa) {
            int dist = dfs(j, u) + w[i];
            if (dist > d1) d2 = d1, d1 = dist;
            else if (dist > d2) d2 = dist;
        }
    }
    d[u] = d1 + d2;
    return max(d1, d2);
}
```





[树的直径证明](https://blog.csdn.net/xianpingping/article/details/104916692)







#### LCA

求LCA的方法主要有：**向上标记法**和**树上倍增法**，离线算法有**Tarjan算法**





##### 树上倍增法

```cpp
// dep[i]表示结点i到根结点的深度, fa[i][k]表示结点i向上走2^k步到达的祖先结点
void bfs() {
    memset(dep, 0x3f, sizeof dep);
    dep[0] = 0, dep[1] = 1;
    queue<int> q;
    q.push(1);
    
    while (!q.empty()) {
        auto t = q.front();
        q.pop();
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            if (dep[j] > dep[t] + 1) {
                dep[j] = dep[t] + 1;
                q.push(j);
                
                // 初始化j向上走一步即父结点t
                fa[j][0] = t;
                for (int k = 1; k < 18; k++) {
                    fa[j][k] = fa[fa[j][k - 1]][k - 1];
                }
            }
        }
    }
}
int lca(int a, int b) {
    if (dep[a] < dep[b]) swap(a, b);
    for (int i = 15; i >= 0; i--) {
        if (dep[fa[a][i]] >= dep[b]) {
            a = fa[a][i];
        }
    }
    if (a == b) return a;
    for (int i = 15; i >= 0; i--) {
        if (fa[a][i] != fa[b][i]) {
            a = fa[a][i];
            b = fa[b][i];
        }
    }
    return fa[a][0];
}
```





##### Tarjan求LCA

```cpp
void dfs(int u, int fa) {
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (j == fa) continue;
        dist[j] = dist[u] + w[i];
        dfs(j, u);
    }
}

void tarjan(int u) {
    st[u] = 1;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (st[j]) continue;
        tarjan(j);
        p[j] = u;
    }
    // query[u]表示结点u中，x为输入数据的编号，y另一个结点
    // res[x]即为u到y的最短距离
    for (auto t : query[u]) {
        int x = t.first, y = t.second;
        if (st[y] == 2) {
            int anc = find(y);
            res[x] = dist[u] + dist[y] - 2 * dist[anc];
        }
    }
    st[u] = 2;
}
```







##### 相关习题

| 题目链接                                                     | 说明                                  |
| ------------------------------------------------------------ | ------------------------------------- |
| [1207. 大臣的旅费](https://www.acwing.com/problem/content/description/1209/) | 求树的直径                            |
| [1172. 祖孙询问](https://www.acwing.com/problem/content/1174/) | 倍增法求LCA                           |
| [1171. 距离](https://www.acwing.com/problem/content/1173/)   | Tarjan离线求LCA                       |
| [P1967 货车运输](https://www.luogu.com.cn/problem/P1967)     | 倍增法求树任意两点边权最小+最大生成树 |
| [356. 次小生成树](https://www.acwing.com/problem/content/358/) | 倍增法求树任意两点边权最大与次大边权  |
| [352. 闇の連鎖](https://www.acwing.com/problem/content/354/) | 树上差分问题                          |





### 欧拉通路和欧拉回路

#### 无向图

无向图存在欧拉通路的充要条件是G为连通图，并且G有两个奇度点或无奇度点

推论：

1. 当G有两个奇度点，则欧拉通路必以这两个点为端点
2. 当G为无奇度点的连通图，G必有欧拉回路
3. 当G为欧拉图时，其充分必要条件是不存在奇度点



#### 有向图

有向图存在欧拉通路的充要条件是，有向图的基图为连通的，并且所有点的出度和入度相等，或者除了两个顶点外，其余点的出度等于入度，且这两个顶点的一个顶点的出度与入度之差为1，另一个顶点的出度与入度之差为-1

推论：

1. 当图除两个顶点的出入和入度之差为1，-1之外，其余顶点的出度与入度相等，则图的欧拉通路中两个端点为这两个顶点
2. 当图的所有顶点出度都等于入度，则图存在欧拉回路
3. 有向图为欧拉图的充要条件是图的基图为连通图，并且所有顶点的出入和入度相等







#### 相关习题

| 题目链接                                                     | 说明               |
| ------------------------------------------------------------ | ------------------ |
| [1123. 铲雪车](https://www.acwing.com/problem/content/1125/) | 判断欧拉回路       |
| [1184. 欧拉回路](https://www.acwing.com/problem/content/1186/) | 欧拉回路模板题     |
| [1124. 骑马修栅栏](https://www.acwing.com/problem/content/1126/) | 无向图欧拉回路应用 |
| [1185. 单词游戏](https://www.acwing.com/problem/content/1187/) | 有向图欧拉通路应用 |
| [P1127 词链](https://www.luogu.com.cn/problem/P1127)         | 上题变形           |





### 连通性问题

#### 强连通分量



#### 双连通分量

割点性质

1. 根结点为割点，当前仅当子结点数大于等于2
2. 非根结点u为割点，当前仅当存在一个u的子结点v，v及其子树所有结点均没有返祖边，low[v] >= dfn[u]

桥性质

根据桥的定义，可知u所在的连通块到v所在的连通块，有且仅有(u，v)这一条路，因此桥就是割点严格大于的情况（low[v] > dfn[u]）



点双连通分量

该连通图无割点可以推出下面两条，若满足其中一条则无向连通图为点双连通分量

1. 该连通图任意两条边存在一个包含这两条边的简单环
2. 图中顶点的数量不超过2



边双连通分量





求割点或点双连通分量

```cpp
void tarjan(int u) {
    dfn[u] = low[u] = ++cnt;
    stk.push(u);
    instk[u] = true;
    int flag = 0;
    for (int i = h[u]; i != -1; i = ne[i]) {
        int j = e[i];
        if (!dfn[j]) {
            tarjan(j);
            low[u] = min(low[u], low[j]);
            if (low[j] >= dfn[u]) {
                if (u != root || ++flag >= 2) cut[u] = true;
                dcc_cnt++;
                int y = 0;
                do {
                    y = stk.top();
                    stk.pop();
                    instk[u] = false;
                    dcc[dcc_cnt].push_back(y);
                } while (y != j);
                dcc[dcc_cnt].push_back(u);
            }
        } else low[u] = min(low[u], dfn[j]);
    }
}
```









#### 相关习题



| 题目链接                                                     | 说明                              |
| ------------------------------------------------------------ | --------------------------------- |
| [1174. 受欢迎的牛](https://www.acwing.com/problem/content/1176/) | tarjan缩点+DAG                    |
| [P3387 【模板】缩点](https://www.luogu.com.cn/problem/P3387) | tarjan缩点+DAG+dp                 |
| [367. 学校网络](https://www.acwing.com/problem/content/369/) | tarjan缩点+统计缩点后的出度入度   |
| [P1726 上白泽慧音](https://www.luogu.com.cn/problem/P1726)   | 统计强连通块的信息                |
| [P1262 间谍网络](https://www.luogu.com.cn/problem/P1262)     | 统计缩点后所有入度为0的强连通分量 |
| [1175. 最大半连通子图](https://www.acwing.com/problem/content/1177/) | 缩点+DAG+dp                       |
| [368. 银河](https://www.acwing.com/problem/content/370/)     |                                   |
| [395. 冗余路径](https://www.acwing.com/problem/content/397/) |                                   |
| [1183. 电力](https://www.acwing.com/problem/content/1185/)   | 求割点和统计连通块数量            |
| [363. B城](https://www.acwing.com/problem/content/365/)      |                                   |
| [364. 网络](https://www.acwing.com/problem/content/366/)     |                                   |
| [365. 圆桌骑士](https://www.acwing.com/problem/content/367/) |                                   |
| [396. 矿场搭建](https://www.acwing.com/problem/content/398/) |                                   |





## 动态规划

### 背包

> 背包问题是经典的动态规划问题，背包问题背后隐藏的模型是决策，通过背包问题可以初步了解动态规划的思想，熟练理解状态转移方程，能灵活应用背包问题的状态转移方程是关键。



#### 01背包

* 最基础的背包问题，对于每一件物品来说，有选和不选两种方式，因此这类问题叫做01背包问题

**集合定义**

前i件物品选择若干件物品，放入不超过容积为j的背包产生不同价值的所有方案组成的集合，设该集合中能获得最大价值的为$ f[i][j]$



**状态转移方程**

由于动态规划具有最优子结构和无后效性特点，我们可以用递推式，推出状态转移方程

$ f[i][j]$的子问题即前i - 1件物品选择若干件物品，放入不超过容积为k(k <= j)的背包产生不同价值的所有方案组成的集合，因此子问题的最大价值为$ f[i - 1][k]$，实际上用子问题的集合加上第i件物品的决策就是原问题$ f[i][j]$的集合，因此得出如下状态转移方程
$$
f(i,j) = max\left\{f(i - 1, j), f(i - 1, j - C_i) + W_i\right\},C_i <= j
$$
**空间优化**

上式状态转移方程为二维，因此空间复杂度为**O(NV)**，根据递推的特点，我们可以将空间复杂度优化为**O(N)**

```cpp
for i = 1...N
	for j = 1...C
        f[i][j] = f[i - 1][j];
        if (j >= v) f[i][j] = max(f[i][j], f[i - 1][j - C] + W);
```

我们发现状态转移方程总是只用到了上一层的值，因此我们就用第i层更新第i-1层即可，然而j是从小到大开始枚举体积的，带来的一个问题是假设我们把$ f[i - 1][j - v] $给更新成了第i层的值，那么当j变大时，需要用到的$ j - v$将可能变小，那么第i-1层这值可能已经被第i层更新了，换而言之，我们j从小到大枚举体积，要更新的值可能早已不是第i-1层的值了。但是从j从大到小枚举并不会出现上述问题，更新的思路同上。

```cpp
for i = 1...N
	for j = C...c
        f[i] = max(f[i], f[j - C] + W);
```





#### 完全背包

* 与01背包不同的是每个物品的数量是无限的

**集合定义**

前i件物品选择若干件物品，放入不超过容积为j的背包产生不同价值的所有方案组成的集合，设该集合中能获得最大价值的为$ f[i][j]$

**状态转移方程**

显然如果决策同01背包一样每个物品只有选和不选，由于有无限个物品需要枚举多个物品，时间复杂度显然会高，我们可以尝试每个物品选多少件进行决策，时间复杂度为$O(NV{\frac{C_i}{S_i}})$,时间复杂度较高
$$
f(i,j) = max\left\{f(i - 1, j - kC_i) + kW_i\right\},kC_i <= j
$$

然而时间复杂度我们仍可以优化为**O(NV)**,展开上述表达式
$$
f(i,j) = max\left\{f(i - 1, j), f(i - 1, j - C_i) + W_i,...,f(i - 1, j - kC_i) + kW_i\right\}, kC_i <= j
$$
类似的
$$
f(i,j - C_i) = max\left\{f(i - 1, j - C_i), f(i - 1, j - 2C_i) + W_i,...,f(i - 1, j - (k - 1)C_i) + (k - 1)W_i\right\},(k-1)C_i <= j
$$
合并两个状态转移方程得到
$$
f(i,j) = max\left\{f(i - 1, j), f(i, j - C_i) + W_i\right\}, kC_i <= j
$$
**空间优化**

和01背包不同，优化第一维的状态中，我们是要更新第i层的值，因此需要正序枚举体积，思考的思路同01背包空间优化思路相同

```cpp
for i = 1...N
	for j = c...C
        f[j] = max(f[j], f[j - C] + W);
```






#### 多重背包

**转化成01背包问题**

多一层循环枚举每个物品的数量，时间复杂度为$O(\sum{_1^n}{}V_iS_i)$，其中$V_i$为物品的体积，$S_i$为物品的数量
$$
f(i,j) = max\left\{f(i - 1, j - kC_i) + kW_i\right\},kC_i <= j
$$
**二进制优化**

将第$i$个物品拆分成若干件01背包物品，二进制拼凑方式一定能够表示某个物品的数量，因此将每个物品拆分成$2^k$个，再用01背包问题求解



**单调队列优化**

根据最初的多重背包一维状态转移方程可以写出
$$
f(j) = max\left\{f(j), f(j - C_i) + W_i, f(j - 2C_i) + 2W_i, f(j - 3C_i) + 3W_i, ..., f(j - kC_i) + kW_i\right\}, kC_i <= j
$$
显然我们是需要求出第i-1层，长度为k的区间的最大值，我们发现数组中的 $j - kC_i$可以使得将其分成$j$类，然后用滑动窗口来维护每一类的最大值
$$
f(j) = max\left\{f(j)\right\}
$$

$$
f(j + C_i) = max\left\{f(j), f(j + C_i) - W_i\right\} + W_i
$$

$$
f(j + 2C_i) = max\left\{f(j), f(j + C_i) - W_i, f(j + 2C_i) - 2W_i\right\} + 2W_i
$$

有了上式我们可以发现入队的值为$f(j + k*C_i) - Wi$，最终结果只需减去$k*C_i$





#### 混合背包

混合背包是将01背包、完全背包、多重背包混合应用，基本思路是将第i个物品看成01背包的思路，按该物品不同类型，同上述三种背包进行循环求解





#### 二维费用背包

只需多加一维状态表示物品的重量，再用01背包思路求解，空间优化方式也同01背包
$$
f(i,j,k) = max\left\{f(i - 1, j - C_i, k - M_i) + W_i\right\}
$$


#### 分组背包

思路同01背包差不多，只不过每一组是选择1件物品或者都不选

**集合定义**

前i组中选择若干件物品，使得背包容量不超过j的所有方案组成的集合，设该集合中能获得最大价值的为$ f[i][j]$

**状态转移方程**
$$
f(i,j) = max\left\{f(i - 1, j - C_{ik}) + W_{ik}\right\}
$$


**空间优化**

同01背包一样，该状态转移方程可以进行空间优化，但是由于每一组最多只能选一件物品，因此可以通过枚举的顺序来确保我们最多选了一件物品

```cpp
for i = 1...N
	for j = C...0
        for k = 1..s[i]
        	f[i] = max(f[i], f[j - C] + Wik);
```





#### 依赖背包

* 由于所有物品构成了一棵树且需要选择根结点的物品后才能选择子结点，因此可以用树形dp的思想去考虑集合表示以及状态转移方程



**集合定义**

以某件物品i为根结点，选择该物品并选择了该物品的若干个孩子结点，使得所有物品总体积不超过j的所有方案组成的集合，设该集合最大能获得最大价值为$f[i][j]$



**状态转移方程**
$$
f[fa][j] = max\left\{f[fa][j], f[i][j - C_{i}] + W_i\right\}
$$
递归时，计算$f[son][j]$后，对于一个孩子结点来说，父结点只能选择某一个体积，因此以孩子结点的体积分组，将其看做分组背包问题，对于父结点来说，所有孩子结点的选择可以看成一个01背包问题



#### 背包与方案



**求最优解的方案数**

* 以01背包求方案数为例，决策只有选和不选，我们需要用一个数组g来维护每个集合状态最优方案数，由以下01背包状态转移方程可知

$$
f(i,j) = max\left\{f(i - 1, j), f(i - 1, j - C_i) + W_i\right\},C_i <= j
$$

* 不选该物品有$f(i,j) = f(i - 1,j)$，则$g[i][j] = g[i][j] + g[i - 1][j]$
* 选该物品有$f(i,j) = f(i - 1, j - C_i)$，则$g[i][j] = g[i][j] + g[i - 1][j - C_i]$

同时需要注意初始化，$g[i][j] = 1，i = 0$当，表示我们一件也不选时也是一种方案数



**输出最优解方案**

假设我们通过01背包的状态转移方程求出了所有集合的最优解$f(i,j)$，对应该集合关系可以看做成有向无环图，我们一定能通过逆推的方式找到某一件物品是选还是没选，伪代码如下

$i\leftarrow N， j\leftarrow V$

while $i > 0$

​    if $j >= C_i, f[i][j] = f[i - 1][j - C_i] + W_i$

​        print 选择了物品$i$

​        $j \leftarrow j - C_i$

​    $i \leftarrow i - 1$



**输出字典序最小的最优方案**

上述伪代码我们是逆推选择了哪些物品，而字典序要求了我们优先选择前面的物品，那么我们只需要逆向枚举物品进行状态转移方程，再采用上述伪代码就一定能够枚举到字典序最小的最优方案







#### 相关习题

| 题目链接                                                     | 说明                |
| ------------------------------------------------------------ | ------------------- |
| [2. 01背包问题](https://www.acwing.com/problem/content/2/)   | 例题                |
| [3. 完全背包问题](https://www.acwing.com/problem/content/3/) | 例题                |
| [4. 多重背包问题 I](https://www.acwing.com/problem/content/4/) | 例题                |
| [5. 多重背包问题 II](https://www.acwing.com/problem/content/5/) | 例题                |
| [6. 多重背包问题 III](https://www.acwing.com/problem/content/6/) | 例题                |
| [7. 混合背包问题](https://www.acwing.com/problem/content/7/) | 例题                |
| [8. 二维费用的背包问题](https://www.acwing.com/problem/content/8/) | 例题                |
| [9. 分组背包问题](https://www.acwing.com/problem/content/9/) | 例题                |
| [10. 有依赖的背包问题](https://www.acwing.com/problem/content/10/) | 例题                |
| [11. 背包问题求方案数](https://www.acwing.com/problem/content/11/) | 例题                |
| [12. 背包问题求具体方案](https://www.acwing.com/problem/content/12/) | 例题                |
| [423. 采药](https://www.acwing.com/problem/content/425/)     | 01背包问题          |
| [426. 开心的金明](https://www.acwing.com/problem/content/428/) | 01背包问题          |
| [487. 金明的预算方案](https://www.acwing.com/problem/content/489/) | 分组背包问题        |
| [1047. 糖果](https://www.acwing.com/problem/content/1049/)   | 01背包问题          |
| [587. 吃蛋糕](https://www.acwing.com/problem/content/589/)   | 完全背包问题        |
| [1024. 装箱问题](https://www.acwing.com/problem/content/1026/) | 01背包问题          |
| [1022. 宠物小精灵之收服](https://www.acwing.com/problem/content/1024/) | 二位费用背包问题    |
| [278. 数字组合](https://www.acwing.com/problem/content/280/) | 背包方案数问题      |
| [1023. 买书](https://www.acwing.com/problem/content/1025/)   | 背包方案数问题      |
| [1021. 货币系统](https://www.acwing.com/problem/content/1023/) | 完全背包方案数问题  |
| [1019. 庆功会](https://www.acwing.com/problem/content/1021/) | 多重背包问题        |
| [1020. 潜水员](https://www.acwing.com/problem/content/1022/) | 二位费用背包问题    |
| [1013. 机器分配](https://www.acwing.com/problem/content/1015/) | 分组背包求方案数    |
| [1454. 异或和是质数的子集数](https://www.acwing.com/problem/content/1456/) | 判断质数+01背包问题 |
| [1487. 取硬币](https://www.acwing.com/problem/content/1489/) | 混合背包+求方案数   |
| [1252. 搭配购买](https://www.acwing.com/problem/content/1254/) | 并查集+01背包问题   |
| [532. 货币系统](https://www.acwing.com/problem/content/534/) | 完全背包+数论       |
| [1226. 包子凑数](https://www.acwing.com/problem/content/1228/) | 数论+完全背包问题   |
| [1234. 倍数问题](https://www.acwing.com/problem/content/1236/) | 贪心+01背包问题     |
| [279. 自然数拆分](https://www.acwing.com/problem/content/281/) | 完全背包问题        |
| [281. 硬币](https://www.acwing.com/problem/content/description/283/) | 多重背包可行性问题  |
| [318. 划分大理石](https://www.acwing.com/problem/content/320/) | 多重背包可行性问题  |
| [280. 陪审团](https://www.acwing.com/problem/content/282/)   | 01背包+输出方案     |
| [734. 能量石](https://www.acwing.com/problem/content/736/)   | 贪心+01背包         |





### 线性DP+经典模型

#### 方格模型

方格模型的特点是每个点都有对应的坐标，且都是从左上角走到右下角，对于这样的模型有几个特点，结合这几个特点就能加快对这类问题的解题速度

1. 对于每个点都对应了一个坐标$(x,y)$，因此状态转移方程至少需要两维来表示坐标
2. 只能向右和向下走，假设当前坐标为$(x, y)$需要从左边走过来的$(x, y - 1)$和从上面走过来$(x - 1, y)$两个状态来考虑状态转移方程
3. 每多一个变量需要多加一维来表示这个变量的状态，如地宫取宝中，需要知道当前状态的物品数量，还需要知道最大的物品的价值，因此需要多加两维
4. 对于一个$n*m$的方格模型来说，由于只能向右或者向下走，从$(1,1)$走到$(n, m)$无论如何走，都一定走了$n+m - 1$步
5. 需要特别注意初始化的问题

#### 最长上升子序列与最长公共子序列模型

最长上升子序列（Longest Increasing Subsequence）简称LIS，其动态规划的转移方程可以从“以当前结尾的字母”这一特征去推，最长上升子序列状态转移方程如下
$$
f(i) = max \{\ f(j) + 1 \}\ (j < i, a[j] < a[i])
$$
最长公共子序列（Longest Common Subsequence）简称LCS，由于涉及了两个字符串，因此我们需要用两维来表示这两个字符串，显然我们是以两个字符串当前字母为结尾来进行状态转移
$$
f(i, j) = max \{\ f(i, j - 1), f(i - 1, j)\}\ (i,j > 0, a_i \neq b_j)
$$

$$
f(i, j) = f(i - 1, j - 1) + 1 (i,j > 0, a_i = b_j)
$$



#### 相关习题

| 题目链接                                                     | 说明                    |
| ------------------------------------------------------------ | ----------------------- |
| [1015. 摘花生](https://www.acwing.com/problem/content/1017/) | 方格模型                |
| [1018. 最低通行费](https://www.acwing.com/problem/content/1020/) | 方格模型                |
| [1027. 方格取数](https://www.acwing.com/problem/content/1029/) | 方格模型                |
| [2067. 走方格](https://www.acwing.com/problem/content/2069/) | 方格模型求方案数        |
| [1212. 地宫取宝](https://www.acwing.com/problem/content/1214/) | 方格模型求方案数        |
| [275. 传纸条](https://www.acwing.com/problem/content/277/)   | 方块模型                |
| [1017. 怪盗基德的滑翔翼](https://www.acwing.com/problem/content/1019/) | 最长上升子序列模型      |
| [1014. 登山](https://www.acwing.com/problem/content/1016/)   | 最长上升子序列模型      |
| [482. 合唱队形](https://www.acwing.com/problem/content/484/) | 思路同上题              |
| [1012. 友好城市](https://www.acwing.com/problem/content/1014/) | 最长上升子序列模型      |
| [1016. 最大上升子序列和](https://www.acwing.com/problem/content/1018/) | 最长上升子序列模型      |
| [1010. 拦截导弹](https://www.acwing.com/problem/content/1012/) | 贪心+最长不上升子序列   |
| [187. 导弹防御系统](https://www.acwing.com/problem/content/189/) | 迭代加深+最长上升子序列 |
| [897. 最长公共子序列](https://www.acwing.com/problem/content/899/) | 最长公共子序列          |
| [272. 最长公共上升子序列](https://www.acwing.com/problem/content/274/) | LIS与LCS结合版          |
| [271. 杨老师的照相排列](https://www.acwing.com/problem/content/273/) | 线性dp                  |
| [312. 乌龟棋](https://www.acwing.com/problem/content/314/)   | 线性dp                  |
| [313. 花店橱窗](https://www.acwing.com/problem/content/315/) | 线性dp                  |
| [1214. 波动数列](https://www.acwing.com/problem/content/1216/) | 蓝桥杯真题              |







### 区间DP

常见套路是先枚举长度以及左右区间，进行状态转移方程，需要注意初始化和边界问题

```cpp
for (int len = 1; len <= n; len++) {
    for (int ll = 1; ll + len - 1 <= n; ll++) {
        int rr = ll + len - 1;
        for (int k = ll; k <= rr; k++) {
            f[ll][rr] = max(f[ll][rr], f[ll][k] + f[k + 1][rr]);
        }
    }
}
```



#### 相关习题

| 题目链接                                                     | 说明              |
| ------------------------------------------------------------ | ----------------- |
| [282. 石子合并](https://www.acwing.com/problem/content/284/) | 区间dp经典例题    |
| [1068. 环形石子合并](https://www.acwing.com/problem/content/1070/) | 上题拓展          |
| [479. 加分二叉树](https://www.acwing.com/problem/content/481/) | 区间dp+二叉搜索树 |
| [320. 能量项链](https://www.acwing.com/problem/content/322/) | 注意边界          |





### 树形DP

树形dp指在树上采用动态思想，树形dp一般是先将子树的子问题求解完毕后再对当前结点进行求解

换根dp应用于状态转移结点依赖于父结点，此时的一般步骤是

1. 先指定一个根结点
2. 一次dfs统计子树内的所有结点对当前结点的贡献
3. 一次dfs统计父结点对当前结点的贡献并合并和统计答案



#### 相关习题

| 题目链接                                                     | 说明                         |
| ------------------------------------------------------------ | ---------------------------- |
| [285. 没有上司的舞会](https://www.acwing.com/problem/content/287/) | 树形dp经典例题               |
| [323. 战略游戏](https://www.acwing.com/problem/content/325/) | 树形dp经典例题               |
| [286. 选课](https://www.acwing.com/problem/content/288/)     | 虚拟结点+依赖背包            |
| [1077. 皇宫看守](https://www.acwing.com/problem/content/1079/) | 确定子结点父结点自身结点状态 |
| [P3478 [POI2008]STA-Station](https://www.luogu.com.cn/problem/P3478) | 换根dp例题                   |
| [1073. 树的中心](https://www.acwing.com/problem/content/1075/) | 换根dp                       |
| [P2986 [USACO10MAR]Great Cow Gathering G](https://www.luogu.com.cn/problem/P2986) | 换根dp                       |
| [CF1187E Tree Painting](https://www.luogu.com.cn/problem/CF1187E) | 换根dp                       |
| [1074. 二叉苹果树](https://www.acwing.com/problem/content/1076/) | 依赖背包                     |
| [1220. 生命之树](https://www.acwing.com/problem/content/1222/) | 树形dp真题                   |
| [1072. 树的最长路径](https://www.acwing.com/problem/content/description/1074/) | 树的直径                     |
| [1078. 旅游规划](https://www.acwing.com/problem/content/description/1080/) | 树的直径+树的中心            |





### 状态压缩DP

#### 相关习题

| 题目链接                                                     | 说明                   |
| ------------------------------------------------------------ | ---------------------- |
| [91. 最短Hamilton路径](https://www.acwing.com/problem/content/93/) | 状态压缩dp解决TSP问题  |
| [731. 毕业旅行问题](https://www.acwing.com/problem/content/description/733/) | 上题变形题             |
| [291. 蒙德里安的梦想](https://www.acwing.com/problem/content/293/) | 状态压缩dp求方案数     |
| [292. 炮兵阵地](https://www.acwing.com/problem/content/294/) | 状态压缩dp空间优化     |
| [327. 玉米田](https://www.acwing.com/problem/content/329/)   | 状态压缩dp求方案数     |
| [1064. 小国王](https://www.acwing.com/problem/content/1066/) | 状态压缩dp求方案数     |
| [524. 愤怒的小鸟](https://www.acwing.com/problem/content/526/) | 状态压缩解重复覆盖问题 |
| [1243. 糖果](https://www.acwing.com/problem/content/1245/)   | 背包思想+状态压缩      |
| [529. 宝藏](https://www.acwing.com/problem/content/531/)     | 最小生成树+状态压缩    |







### 状态机模型

#### 有限状态机

**特点**

1. 可以用状态来描述事物，事物某一时刻总处于一种状态
2. 事物拥有的状态是有限的
3. 事物可以从一个状态转移到另一个状态



**在dp上的应用**

对于一个dp问题不好确定状态转移方程，我们可以泛化题目的意思分析出题目的多个状态及其数量，利用有限状态机的模型，确定状态之间的关系，最后得出状态转移方程

下面通过状态机模型解股票这类题来梳理状态机解决dp问题步骤

**股票买卖1**

* 分析题目，我们可以得到两个状态，持有和未持有股票

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B.png?raw=true)

根据上图的状态机，我们很容易写出状态转移方程
$$
f(i,0,0) = max\{\ f(i - 1,0,0) \}\
$$

$$
f(i, 1, 0) = max\{\ f(i - 1,1, 0), f(i - 1, 0, 0) - a_{i} \}\
$$

$$
f(i,0,1) = max\{\ f(i - 1,0,1), f(i - 1, 1, 0) + a_{i} - a_{i-1} \}\
$$



其中$f(i,0,0)$表示第i天未持有股票所能获得的最大利润且卖出次数为0次，$f(i, 1, 0)$表示第i天持有股票所能获得的最大利润且卖出次数为0次，$f(i, 0, 1)$表示第i天未持有股票所能获得的最大利润且卖出次数为1次

**股票买卖2**

与上一题不同的是，本题不限制交易次数，因此我们可以把第三维度记录交易次数状态删去，得到状态转移方程
$$
f(i,0) = max\{\ f(i - 1, 0), f(i - 1, 1) + a_i) \}\
$$

$$
f(i, 1) = max\{\ f(i - 1, 1), f(i - 1, 0) - a_i\}\;
$$

**股票买卖3**

本题是限制交易次数为2次，因此第三维度用来记录交易次数，思路同题1类似



**股票买卖4**

本题将交易次数一般化成k次，思路同上面三题类似



**股票买卖5**

本题卖出股票后含为期1天的冷冻期，也就是卖出股票至少1天后才能买入股票，不难推出本题状态除了持有股票和未持有股票，还包括了卖出后的状态：冷冻期，而且买入时一定处于未冷冻期，因此状态机包含了3个状态

![](https://github.com/MichaelDeSteven/DataStruct-And-Algorithm/blob/master/pic/%E7%8A%B6%E6%80%81%E6%9C%BA2.png?raw=true)

根据上图的状态机，我们很容易写出状态转移方程
$$
f(i,0) = max\{\ f(i - 1,0), f(i - 1, 2) \}\
$$

$$
f(i, 1) = max\{\ f(i - 1, 1), f(i - 1, 0) - a_i\}\
$$

$$
f(i, 2) = max\{\ f(i - 1, 1) + a_i\}\
$$



其中$f(i,0)$表示第i天未持有股票所能获得的最大利润，$f(i, 1)$表示第i天持有股票所能获得的最大利润，$f(i, 2)$表示第i天处于冷冻期获得的最大利润



**股票买卖6**

状态机模型同第一个状态机图，思路类似



#### 相关习题

| 题目链接                                                     | 说明     |
| ------------------------------------------------------------ | -------- |
| [1054. 股票买卖](https://www.acwing.com/problem/content/1056/) | 例题     |
| [1055. 股票买卖 II](https://www.acwing.com/problem/content/1057/) | 例题     |
| [1056. 股票买卖 III](https://www.acwing.com/problem/content/1058/) | 例题     |
| [1057. 股票买卖 IV](https://www.acwing.com/problem/content/1059/) | 例题     |
| [1058. 股票买卖 V](https://www.acwing.com/problem/content/1060/) | 例题     |
| [1059. 股票买卖 VI](https://www.acwing.com/problem/content/1061/) | 例题     |
| [LCP 19. 秋叶收藏集](https://leetcode-cn.com/problems/UlBDOe/) | 三个状态 |







### 记忆化搜索

记忆化搜索是动态规划的另一种形式，由于动态规划具有最优子结构和无后效性两个性质，因此我们可用循环和递推的方式求解，而记忆化搜索是从大的问题开始分解，若当前的问题的最优解已经求解过，则将其放入“备忘录”中，下一次求解该问题只需查询备忘录而不用重复地进行搜索，可以说记忆化搜索更接近于动态规划的本质，利用“空间换时间”的思想，动态规划是对“暴力算法“的一种优化





#### 相关习题

| 题目链接                                                     | 说明                 |
| ------------------------------------------------------------ | -------------------- |
| [901. 滑雪](https://www.acwing.com/problem/content/903/)     | 例题                 |
| [1212. 地宫取宝](https://www.acwing.com/problem/content/1214/) | 走方格记忆化搜索写法 |
| [282. 石子合并](https://www.acwing.com/problem/content/284/) | 区间dp记忆化搜索写法 |
| [321. 棋盘分割](https://www.acwing.com/problem/content/323/) | 区间dp+二维前缀和    |

 



## 树状数组与线段树



### 树状数组

作用

* 修改区间某个数$O(logN)$
* 查询前缀和$O(logN)$
* 修改区间（利用差分）
* 查询区间

参考资料：[树状数组](https://www.acwing.com/blog/content/1818/)



```cpp
int lowbit(int x) {
    return x & -x;
}

// 单点修改：点x加上y
void add(int x, int y) {
    for (int i = x; i < N; i += lowbit(i)) tr[i] += y;
}

// 区间查询
int query(int x) {
    int sum = 0;
    for (int i = x; i; i -= lowbit(i)) sum += tr[i];
    return sum;
}
```





#### 相关习题

| 题目链接                                                     | 说明                 |
| ------------------------------------------------------------ | -------------------- |
| [1264. 动态求连续区间和](https://www.acwing.com/problem/content/1266/) | 模板题               |
| [788. 逆序对的数量](https://www.acwing.com/problem/content/790/) | 树状数组求逆序对个数 |
| [241. 楼兰图腾](https://www.acwing.com/problem/content/243/) | 树状数组简单应用     |
| [242. 一个简单的整数问题](https://www.acwing.com/problem/content/248/) | 树状数组区改单查     |
| [243. 一个简单的整数问题2](https://www.acwing.com/problem/content/244/) | 树状数组区改区查     |
| [244. 谜一样的牛](https://www.acwing.com/problem/content/245/) | 树状数组+二分        |
| [1215. 小朋友排队](https://www.acwing.com/problem/content/1217/) | 逆序对变形题         |
| [1265. 数星星](https://www.acwing.com/problem/content/1267/) | 树状数组简单应用     |
| [1266. 校门外的树](https://www.acwing.com/problem/content/1268/) | 树状数组简单应用     |
| [1267. 清点人数](https://www.acwing.com/problem/content/1269/) | 树状数组简单应用     |



### 线段树

作用

* 单点修改
* 区间修改
* 查询区间



参考资料：[线段树](https://www.acwing.com/blog/content/1826/)



```cpp
// 以区间修改，区间查询为例
struct node {
    int l, r, add;
    LL sum;
} seg[4*N];
int n, m;
LL w[N];

void pu(int u) {
    seg[u].sum = seg[u << 1].sum + seg[u << 1 | 1].sum;
}

void pd(int u) {
    auto &root = seg[u], &left = seg[u << 1], &right = seg[u << 1 | 1];
    if (root.add) {
        left.add += root.add, left.sum += (LL)(left.r - left.l + 1) * root.add;
        right.add += root.add, right.sum += (LL)(right.r - right.l + 1) * root.add;
        root.add = 0;
    }
}

void build(int u, int ll, int rr) {
    if (ll == rr) {
        seg[u] = {ll, ll, 0, w[ll]};
        return;
    }
    
    // 对左右子区间递归
    int mid = ll + rr >> 1;
    build(u << 1, ll, mid), build(u << 1 | 1, mid + 1, rr);
    // 建立父区间
    seg[u] = {ll, rr, 0, 0};
    pu(u);
}

void modify(int u, int ll, int rr, int v) {
    if (seg[u].l >= ll && seg[u].r <= rr) {
        seg[u].sum += (LL)(seg[u].r - seg[u].l + 1) * v;
        seg[u].add += v;
        return;
    }
    // modify时先pd操作，更新子区间
    pd(u);
    // seg[u].l + seg[u].r为当前区间中间
    int mid = seg[u].l + seg[u].r >> 1;
    // ll, rr为要修改的区间，不能变！
    if (ll <= mid) modify(u << 1, ll, rr, v);
    if (rr >= mid + 1) modify(u << 1 | 1, ll, rr, v);
    // 子区间更新完后更新父区间
    pu(u);
}

LL query(int u, int ll, int rr) {
    if (seg[u].l >= ll && seg[u].r <= rr) return seg[u].sum;
    // 先更新子区间
    pd(u);
    // ll, rr为要查询的区间，不能变！
    int mid = seg[u].l + seg[u].r >> 1;
    LL sum = 0;
    if (ll <= mid) sum = query(u << 1, ll, rr);
    if (rr >= mid + 1) sum += query(u << 1 | 1, ll, rr);
    return sum;
}
```





#### 相关习题

| 题目链接                                                     | 说明                 |
| ------------------------------------------------------------ | -------------------- |
| [1264. 动态求连续区间和](https://www.acwing.com/problem/content/1266/) | 模板                 |
| [1275. 最大数](https://www.acwing.com/problem/content/1277/) | 线段树简单应用       |
| [245. 你能回答这些问题吗](https://www.acwing.com/problem/content/246/) | 线段树单点修改变形题 |
| [1270. 数列区间最大值](https://www.acwing.com/problem/content/1272/) | RMQ问题              |
| [246. 区间最大公约数](https://www.acwing.com/problem/content/247/) | 数论+树状数组+线段树 |
| [243. 一个简单的整数问题2](https://www.acwing.com/problem/content/244/) | 懒标记简单应用       |
| [247. 亚特兰蒂斯](https://www.acwing.com/problem/content/249/) | 扫描线（了解         |
| [1277. 维护序列](https://www.acwing.com/problem/content/1279/) | 懒标记应用           |







## 贪心







## 相关数学知识



### 数论

#### 整除的性质

**带余除法定理**：对于 $a、b \in Z, b \neq 0$,一定唯一存在一对整数$p、r$使得$a = qb + r, 0 \le r \lt \left| b \right|$ 

**整除**：若$r = 0$，说明b能整除a，则记$b|a$，对于给定任意$a \in Z$有$a|0$， 特别的$0|0$

**反身性**：$\forall a \in Z$有$a|a$

**传递性**：若$a|b$且$b|c$则$a|c$

>a|b 推出 b = ax，类似的c = by，因此c = axy，由于x、y均为整数所以a|c

**常用定理**：

若$b|a_i, i = 1,2,3...,s$,则对于任意整数$u_1,u_2,...,u_s$有$b| \sum_{i=1}^{s}{u_ia_i}$

>因为$b|a_i$,所以$a_i = bx_i$,将该式代入$\sum_{i=1}^{s}{u_ia_i}$
>
>代入得到 $\sum_{i=1}^{s}{u_ibx_i}$,将b提出来的得到 $sb\sum_{i=1}^{s}{u_ix_i}$
>
>得证





**公因数**：在$Z$中，若$c|a$且$c|b$，则c是a、b的一个公因数



#### 最大公因数

**最大公因数**：在$Z$中，若$c|a$且$c|b$，满足下述两个条件，则称c为a、b的最大公因数（greatest common divisor）记作$(a,b)$

* c是a、b的公因数
* a、b的任意公因数均能整除c

由于$a|a, a|0$，所以a是a与0的公因数，又由于a与0的任意公因数c有$c|a$，因此a是a与0的最大公因数，特别的0与0的最大公因数为0



> 对于任意两个整数来说，是否都存在最大公因数？怎么求最大公因数？



**引理1**：$a、b \in Z, b \neq 0$使得$a = qb + r, 0 \le r \lt \left| b \right|$ 设c为a与b的一个公因数，那么当且仅当c为b、r的一个公因数

>因为c为a与b的一个公因式，得到
>
>$c|a,c|b$
>
>由**带余除法定理**得$r = a - qb, 0 \le r \lt \left| b \right|$
>
>再由常用定理可知c|r
>
>因此$c|a,c|b \Rightarrow c|b, c|r$
>
>进一步的$c|a,c|b \Leftrightarrow c|b, c|r$



**定理1**：c为a与b的一个最大公因数，那么当且仅当c为b、r的一个最大公因数

>由引理1得到c为a、b的一个最大公因数，那么c为b、r的公因数
>
>那么任取d，有$d|b,d|r$
>
>那么d也为a、b的公因数，所以$d|c$
>
>由c为b、r的公因数，d为b、r的公因数，且对于任意d有$d|c$
>
>可知c为b、r的最大公因数



* 启发：对于式子$a = qb + r, 0 \le r \le \left| b \right|$ ，求a、b的最大公约数我们可以转化得去求q、r的最大公约数

$a = qb + r, 0 \lt r \lt \left| b \right|$ 

$b = qr + r_1, 0 \lt r_1 \lt \left| r \right|$ 

$r = qr_1 + r_2, 0 \lt r_2 \lt \left| r_1 \right|$ 

$r1 = qr_2 + r_3, 0 \lt r_3 \lt \left| r_2 \right|$ 

$r_{s-2} = qr_{s-1} + r_s, r_{s} = 0$ 

由于$r_{s-2} = qr_{s-1}$ ，则最大公约数为$r_{s-1}$，进一步的，将式子从下往上代入，我们可以得到最大公约数能用a、b的倍数和来表示。



#### 裴蜀定理

对于$\forall a、b \in N$都存在一个最大公约数d，且$\exists u、v \in N$有$ua+vb=d$



上述的常用定理中$b|a_i, i = 1,2,3...,s$，我们称b为$a_i$的公因数，由于最大公因数d能整除任何b，即我们简单证明了裴蜀定理，通过欧几里得算法我们也能够证明裴蜀定理



**性质1**：若$a|bc$，且$(a, b) = 1$，则$a|c$

>因为$(a, b) = 1$所以$ua+vb=1$
>
>两边同时乘以c，即$uac+vbc=c$
>
>$a|bc$且$a|a$由**常用定理**得$a|c$

**性质2**：若$a|c$，$b|c$，且$(a, b) = 1$，则$ab|c$

> 设$c=ah$，则$b|ah$
>
> 又因为$(a, b) = 1$由性质1得$b|h$
>
> 两边同时乘以a得到$ab|ah$即$ab|c$

**性质3**：若$(a, c) = 1$，$(b, c) = 1$，则$(ab, c) = 1$



#### 欧几里得算法

根据启发，我们容易得出求a、b的最大公约数等价于求b、a%b的最大公约数，当b=0时，此时的a即为最大公约数

```cpp
int gcd(int a, int b) {
    return b ? gcd(b, a % b) : a;
}
```



#### 拓展欧几里得算法

作用：$ax+by=gcd(a,b)=d$,已知a、b求解一组x、y

根据欧几里得算法的启发$gcd(a, b) = gcd(b, a\%b)$ 可以写出等价方程式$bx{_1}+(a \% b)y{_1} = d$，展开该式得到

$$
ay_{1}+b(x_{1} - a / b * y_{1}) = d
$$
我们得到了原x、y的解$x = y_1, y = x_1 - a / b * y_1$



**exgcd解不定方程**

求解不定方程$ax+by=c$

1. 使用exgcd求解$ax+by=(a,b)$得到特解$x_{i},y_{i}$
2. 那么方程所有解的形式为

$$
\left\{
    \begin{array}{l}
            x_{j}=x_{i} + y\frac{c}{(a,b)} \\  y_{j}=y_{i} + x\frac{c}{(a,b)}
        \end{array}
\right.
$$





```cpp
int exgcd(int a, int b, int &x, int &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    int x1 = x, y1 = y;
    int d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
}
```



#### 中国剩余定理

也叫做孙子定理，用于解决同余方程组
$$
\left\{  
             \begin{array}{**lr**}  
             x \equiv a_1\ (mod \ m_1) &  \\  
             x \equiv a_2\ (mod \ m_2) &  \\  
             x \equiv a_3\ (mod \ m_3) &  \\  
             ... &  \\  
             x \equiv a_n\ (mod \ m_n) &  \\  
             \end{array}  
\right.
$$
其中$m_i, i = 1,2,...,n$两两互为质数

则对于任意$a_i, i = 1, 2,...,n$均有解，通解为
$$
x= (\sum_{i = 1}^{n}a_{i}t_{i}M_{i}) \ mod \ M
$$
其中$M = \prod_{i= 1}^{n}m_{i}, \ M_i = \frac{M}{m_i}, \ t_i = M_{i}^{-1}为M_{i}模m_i的逆元$



#### 拓展中国剩余定理

在中国剩余定理中$m_i, i = 1,2,...,n$两两互为质数，若不成立则问题变成了解n个同余方程，也就是变成了求n次exgcd的过程，假设我们已经解出前k-1个方程，则通解为$x + i*M$其中$M = \prod_{i= 1}^{k-1}m_{i}$

将通解代第n个方程中得到$x + i*M \ \equiv \ a_n \ (mod \ m_n)$用exgcd解出即可





**质数**

> 只能被1或自身整除的正整数，也被称为素数

**性质1**：质数的约数只有1和它本身

**性质2**：两个数互质，即$(a,b) = 1$,则存在一组$u、v$，使得$ua + vb = 1$

**性质3**：任意一个大于1的数，均能被分解成有限个质数的积







#### 算术基本定理

任何一个大于1的自然数N，N能被分解如下
$$
N = P_{1}^{a_1}P_{2}^{a_2}P_{3}^{a_3}...P_{n}^{a_n}
$$
其中$P_i$为质数，$a_i$为正整数



**性质1**：约数个数为$({a_1} + 1)({a_2} + 1)({a_3} + 1)...({a_n} + 1)$

**性质2**：约数之和为$(P_{1}^{0}+P_{1}^{1}+...+P_{1}^{a_1})(P_{2}^{0}+P_{2}^{1}+...+P_{2}^{a_2})...(P_{n}^{0}+P_{n}^{1}+...+P_{n}^{a_n})$





```cpp
// 试除法分解质因数，时间复杂度为O(sqrt(n))
void div(int x) {
    for (int i = 2; i <= x / i; i++) {
        if (x % i == 0) {
            int t = 0;
            while (x % i == 0) {
                t++;
                x /= i;
            }
            cout << i << ' ' << t << endl;
        }
    }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```



**筛质数**

```cpp
// 朴素法筛质数,时间复杂度为O(nlogn)
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
// 线性筛质数
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```







#### 欧拉函数

作用：用于求小于等于正整数n与n互质的个数

通式：其中$p_1,p_2,...,p_n$为x的所有质因子
$$
\phi(x) = x\prod_{i = 1}^{n}(1- \frac{1}{p_i})
$$
当x为质数时，有$\phi(x) = x - 1$

欧拉函数为积性函数，所以有$\phi(mn) = \phi(m)\phi(n)$



[欧拉函数](https://blog.csdn.net/qq_39922639/article/details/77511761)

```cpp
// 分解质因数求欧拉函数
int get_euler(int n) {
    int res = n;
    for (int i = 2; i <= n / i; i++) {
        if (n % i == 0) {
            while (n % i == 0) n /= i;
            res = (LL)res * (i - 1) / i;
        }
    }
    if (n > 1) res = (LL)res * (n - 1) / n;
    return res;
}

// 筛法求1~n的欧拉函数
void get_primes(int n) {
    phi[1] = 1;												// 1的欧拉函数为1
    for (int i = 2; i <= n; i++) {
        if (!st[i]) {
            primes[cnt++] = i;						
            phi[i] = i - 1;									// i为质数，欧拉函数为i-1
        }
        for (int j = 0; primes[j] <= n / i; j++) {
            st[i * primes[j]] = true;
            phi[i * primes[j]] = phi[i] * (primes[j] - 1);  // phi[i*primes[j]] = phi[i]*phi[primes[j]]
            if (i % primes[j] == 0) {
                phi[i * primes[j]] = phi[i] * primes[j];	// phi[i]已经包含了primes[j]的质因子，所以直接乘
                break;
            }
        }
    }
}
```





#### 费马-欧拉定理


$$
\alpha^{\phi(n)}\equiv1(mod \ n)
$$
当n为质数时，$\alpha^{n-1}\equiv1(mod \ n)$该式子也叫做费马小定理



#### 逆元

逆元有如下关系
$$
a^{-1}*a=e
$$
其中$e$为单位元，在整数域中，1为单位元，因此也写成$a^{-1}*a=1$，在一个模n剩余系中，$a^{-1}*a \equiv 1 \ (mod \ n)$，我们称$a^{-1}$是a在$mod \ n$下的逆元，在某些问题中需要用到逆元



**法一:快速幂**

由**费马小定理**可知，$\alpha^{n-1}\equiv1(mod \ n)$

将费马小定理左项分解得$\alpha * \alpha^{n-2}\equiv1(mod \ n)$，因此$\alpha$的逆元为$\alpha^{n-2}$，求逆元转化成了用快速幂求$ \alpha^{n-2}$，条件是**n必须为质数**



```cpp
// 求u^(v-2)
LL qmi(LL u, LL v) {
    LL res = 1, base = u, mod = v + 2;
    while (v) {
        if (v & 1) res = (res * base) % mod;
        base = (base * base) % mod;
        v >>= 1;
    }
    return res;
}
```



**法二:拓展欧几里得**

将$a^{-1}*a \equiv 1 \ (mod \ n)$转化成$a*a^{-1} \ + \ nb = 1$然后用exgcd求解$a^{-1}$



```cpp
int exgcd(LL a, LL b, LL &x, LL &y) {
    if (!b) {
        x = 1, y = 0;
        return a;
    }
    LL x1 = x, y1 = y;
    LL d = exgcd(b, a % b, x1, y1);
    x = y1, y = x1 - a / b * y1;
    return d;
}
// 此时逆元为(x / d + p) % p,其中d最大公约数为d, 由于解存在负数情况，所以需要取模运算
```





**法三:线性递推**

给定n，p求1到n在模p下的逆元

根据同余定理得到$p = ki + r$

模p意义下$ki + r \equiv 0(mod \ p)$

两边同时乘以$i^{-1}r^{-1}$得到$kr^{-1} + i^{-1} \equiv 0 (mod \ p)$

变形得到$i^{-1} \equiv -kr^{-1} (mod \ p)$

由同余定理和模运算的意义我们可以得到$k = \lfloor \frac{p}{i} \rfloor$,$r = p \% i$

由于是模p因此i的逆元即为下式
$$
i^{-1} \equiv - \lfloor \frac{p}{i} \rfloor (p \% i)^{-1}mod \ p
$$
我们定义$inv[i]$为i的逆元，由上式可知$(p \% i)^{-1}$我们已经在求i的逆元时求过了，因此只要用递推式就可以线性求出1到n在模p下的逆元

```cpp
inv[1] = 1;
for (int i = 2; i <= n; i++) {
    inv[i] = p - (p / i) * inv[p % i] % p;
}
```





### 线性代数



#### 矩阵&快速幂





#### 高斯消元









### 组合与计数





#### 组合数

$C(n,m)$表示从n个物品中选择m个元素的方案数，用dp的思想，我们很容易得到第一个组合数第一个常用等式
$$
C(n, m) = C(n - 1, m) + C(n - 1, m - 1)
$$
我们从n个物品中拿出一个物品，然后在n-1个物品求组合方案数，若拿取的物品算上，则$C(n - 1, m - 1)$为一类方案，不算拿去的物品，则$C(n - 1, m)$为一类方案



从定义出发
$$
C(n, m) = \frac{n(n-1)(n-2)(n-3)...(n-m+1)}{m!}
$$
也可以写成如下
$$
C(n, m) = \frac{n!}{m!(n - m)!}
$$
我们规定$C(n,0)=1$



当n, m数据量小时，可以利用第一个式子递推来预处理组合数

```cpp
// 注意初始化C[0][0]
C[0][0] = 1;
for (int i = 1; i < N; i++)
    for (int j = 0; j <= i; j++)
        if (!j) C[i][j] = 1;
		else C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % MOD;
```



当n, m数据不大，且求组合数模P（P为质数时）根据第二个式子，我们可以先预处理阶乘，再利用费马小定理和快速幂求逆元

对于$\frac{1}{n} \% p$来说，我们可以写成$nn^{-1}\equiv1(mod \ p)$ 然后根据费马小定理所以$nn^{-1}\equiv n^{p-1}$ ,两边同时乘以$n^{-1}$

所以对于$\frac{1}{n}$的逆元为$n^{p-2}$，再用快速幂求解



当n，m的数据超大，那么需要用到Lucas定理



#### Lucas定理

用于求组合数模P，其中P为质数
$$
C(n, m)\%p = C(n \%p, m \%p)C(\frac{n}{p}, \frac{m}{p}) \%p
$$


#### 卡特兰数

通项公式为
$$
f(n) = \frac{C(2n,n)}{n+1}
$$
递推式为
$$
f(n) = \sum_{i=0}^{n - 1}f(i)f(n - i - 1)
$$
通项公式变形
$$
f(n) = C(2n, n) - C(2n, n - 1)
$$
看到数列1、1、2、5、14、42就往卡特兰数想吧





[卡特兰数浅谈](https://blog.csdn.net/qq_30115697/article/details/88906534)



#### 容斥原理











### 概率与统计





### 博弈论







### 相关习题

| 题目链接                                                     | 说明                 |
| ------------------------------------------------------------ | -------------------- |
| [866. 试除法判定质数](https://www.acwing.com/problem/content/868/) | 判断质数             |
| [867. 分解质因数](https://www.acwing.com/problem/content/869/) | 算数基本定理         |
| [868. 筛质数](https://www.acwing.com/problem/content/870/)   | 线性筛质数模板       |
| [869. 试除法求约数](https://www.acwing.com/problem/content/871/) | 筛约数模板           |
| [870. 约数个数](https://www.acwing.com/problem/content/872/) | 试除法求约数模板     |
| [871. 约数之和](https://www.acwing.com/problem/content/873/) | 试除法暴力求约数之和 |
| [97. 约数之和](https://www.acwing.com/problem/content/99/)   | 分治+快速幂          |
| [872. 最大公约数](https://www.acwing.com/problem/content/874/) | gcd模板题            |
| [873. 欧拉函数](https://www.acwing.com/problem/content/875/) | 分解质因数           |
| [874. 筛法求欧拉函数](https://www.acwing.com/problem/content/876/) | 线性筛               |
| [875. 快速幂](https://www.acwing.com/problem/content/877/)   | 快速幂模板题         |
| [876. 快速幂求逆元](https://www.acwing.com/problem/content/878/) | 费马小定理           |
| [877. 扩展欧几里得算法](https://www.acwing.com/problem/content/879/) | exgcd模板            |
| [878. 线性同余方程](https://www.acwing.com/problem/content/880/) | exgcd解同余方程      |
| [P1495 【模板】中国剩余定理(CRT)/曹冲养猪](https://www.luogu.com.cn/problem/P1495) | 中国剩余定理模板     |
| [P4777 【模板】扩展中国剩余定理（EXCRT）](https://www.luogu.com.cn/problem/P4777) | 扩展中国剩余定理模板 |
| [204. 表达整数的奇怪方式](https://www.acwing.com/problem/content/206/) | 同上                 |
| [883. 高斯消元解线性方程组](https://www.acwing.com/problem/content/885/) | 高斯消元模板         |
| [884. 高斯消元解异或线性方程组](https://www.acwing.com/problem/content/886/) | 习题                 |
| [885. 求组合数 I](https://www.acwing.com/problem/content/887/) | 递推式求组合数       |
| [886. 求组合数 II](https://www.acwing.com/problem/content/888/) | 数论+递推式          |
| [887. 求组合数 III](https://www.acwing.com/problem/content/889/) | Lucas定理            |
| [888. 求组合数 IV](https://www.acwing.com/problem/content/890/) | 高精度               |
| [889. 满足条件的01序列](https://www.acwing.com/problem/content/891/) | 卡特兰数             |
| [890. 能被整除的数](https://www.acwing.com/problem/content/892/) | 容斥原理             |
| [1246. 等差数列](https://www.acwing.com/problem/content/1248/) | 贪心+gcd             |
| [1223. 最大比例](https://www.acwing.com/problem/content/1225/) | 辗转相减法           |
| [1295. X的因子链](https://www.acwing.com/problem/content/1297/) |                      |
| [1296. 聪明的燕姿](https://www.acwing.com/problem/content/1298/) |                      |
| [1299. 五指山](https://www.acwing.com/problem/content/1301/) | exgcd求解同余方程    |
| [1301. C 循环](https://www.acwing.com/problem/content/1303/) | 同上                 |







