# 数据库系统原理

## 基本概念

**数据库的定义**

数据库是**长期**存储在计算机内，有组织可**共享**的**大量**数据集合
数据库数据具有三个基本特点永久存储、有组织、共享



**数据库的优点**

最开始，我们是将数据保存在内存中，这能够保证我们十分快速存取，但是一旦断电，数据就丢失了，无法永久保存。 于是我们将数据存放在文件中，这样一来我们就 能够将数据永久保存，但每次都要进行频繁的 IO 操作，相对于内存来讲速度就慢了许多，而且进行查询操作也不方便。 于是，我们转移到了数据库存储，通过这种方式不但能将永久保存数据，而且查询管理也更加高效方便。





**数据库管理系统**

![image-20210119164302804](C:\Users\Steven\Desktop\CS-Note\数据库\pic\mysql体系结构.png)

1. 位于用户与操作系统之间的一层数据软件
2. 是一个大型复杂的软件系统

作用：科学地组织、存储数据，高效地获取、维护数据



## 数据模型

数据库结构的基础是数据模型。数据模型是一个描述数据、数据联系、数据语义以及一致性约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层设计方式



### 物理数据模型

物理数据模型简称物理模型，它是面向计算机物理表示的模型。描述了数据与存储介质上的组织结构，他不但与DBMS有关，而且与操作系统和硬件有关。每一种逻辑数据模型都有对应的物理数据模型。DBMS为了保证其独立性与可移植性。大部分物理数据模型的实现工作由系统自动完成，而设计者只设计索引、聚集等特殊结构



### 概念数据模型

**基本概念**

包括重要的实体与实体之间的关系。在概念数据模型中不包括实体的属性，也不用定义实体的主键。这是概念模型与逻辑模型的最大区别。表示概念模型最常用的有实体关系图



### 逻辑数据模型

#### 层次模型

![image-20210119175031483](C:\Users\Steven\Desktop\CS-Note\数据库\pic\层次模型.png)

#### 网状模型

![image-20210119175040827](C:\Users\Steven\Desktop\CS-Note\数据库\pic\网状模型.png)

#### 关系模型

**定义**

![image-20210119175109302](C:\Users\Steven\Desktop\CS-Note\数据库\pic\关系模型.png)



三要素

* 数据结构
* 数据操作
* 完整性约束



**数据结构**

数据结构指数据对象与对象之间联系的表达，是系统的静态描述包括两个方面

数据本身：类型、内容、性质。例如关系模式中的域、属性、关系等

数据之间的关系：数据之间是如何相互联系的，如关系的主码、外码等



**数据操作**

对数据库中对象（型）和实例（值）允许执行的操作集合。主要是检索和更新（插入、删除、修改）两类操作。数据操作是对系统动态特征的描述

**完整性约束**

是一组完整性规则的集合，规定数据库状态以及状态变化所应满足的条件，以保证数据的正确性，相容性，有效性。包括了用户自定义完整性和实体完整性

实体完整性：若属性A为基本关系R的主属性，则A不能为空

参照完整性：若F为基本关系R的一个或一组属性，但不是主属性，Ks是基本关系S的主码，如果F与Ks对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系

用户自定义完整性：针对用户的不同需求



**优缺点**

![image-20210119175149316](C:\Users\Steven\Desktop\CS-Note\数据库\pic\关系模型优缺点.png)



## 关系数据库设计理论

### 函数依赖

### 范式





## 数据库管理系统组成

### 概要

![image-20210115223554905](C:\Users\Steven\Desktop\CS-Note\数据库\pic\数据库管理系统流程图.png)

数据库系统划分为不同的模块。每个模块完成系统的一个功能。数据库系统的功能部件大致可分为存储管理器和查询处理器。

查询处理器：用于帮助数据库系统简化和方便数据访问。

存储管理器：负责在数据库中存储的低层数据与应用程序以及向系统提交的查询之间提供接口的部件。存储管理器负责与文件管理器进行交互。原始数据通过操作系统提供的文件系统存储在磁盘上。磁盘管理器将各种DML语句翻译为底层文件系统命令。因此，存储管理器负责数据库中数据的存储、检索和更新



### 查询处理器



### 存储管理器

#### 事务管理器

作用：保证即使发生了故障，数据库也保持在一致的（正确的）状态，并保证并发事物的执行不发生冲突



#### 文件管理器

管理磁盘存储空间的分配，管理用于表示磁盘上所存储信息的数据结构



#### 权限和完整性管理器

检测是否满足完整性约束，并检测试图访问数据的用户的权限



#### 缓冲区管理器

负责将数据从磁盘上取到内存中来，并决定哪些数据应被缓冲存储在内存中。



### 磁盘管理









# SQL

## 性能分析

### Explain

**作用**

* 表的读取顺序（id）
* 数据读取的操作类型（select_type）
* 查询表用了什么类型（type）
* 使用的索引（key）



![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\Explain表头.png)

**id**

执行优先级

* id相同，执行顺序由上到下
* id不同，大的先执行



**select_type**

查询类型

* SIMPLE：简单的SELECT查询，查询中不包含子查询或者join
* PRIMARY：查询中若包含任何复杂的子部分，最外层的表标记的
* SUBQUERY：在SELECT或WHERE列表包含了子查询
* DERIVED：在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表里
* UNION：若第二个SELECT出现在UNION之后，会被标记为UNION
* UNION RESULT：UNION合并的结果集



**table**

表名



**type**

显示查询用了何种类型

性能从好到差依次为

system>const>eq_ref>ref>range>index>ALL

* system：表中只有一行记录
* const：表示通过索引一次就找到了
* eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配
* ref：非唯一性索引扫描，返回匹配某个单独值的所有行
* range：只检索给定范围的行，使用一个索引来选择行
* index：全索引扫描，index与ALL区别为index类型只遍历索引树
* ALL：全表扫描



**possible_keys**

显示可能应用到这张表的索引



**key**

实际使用的索引



**key_len**

表示索引中使用的字节数



**ref**

显示索引的哪一列被使用了，如果可能的话，是一个常数。





**rows**

每张表有多少行被优化器查询



## 数据类型

### 数值类型

| 类型      | 大小                                   | 用途       |
| --------- | -------------------------------------- | ---------- |
| TINYINT   | 1B                                     | 小整数值   |
| SMALLINT  | 2B                                     | 大整数值   |
| MEDIUMINT | 3B                                     | 大整数值   |
| INT       | 4B                                     | 大整数值   |
| BIGINT    | 8B                                     | 极大整数值 |
| FLOAT     | 4B                                     | 单精度     |
| DOUBLE    | 8B                                     | 双精度     |
| DECIMAL   | DECIMAL(M, D)如果M > D为M+2，否则为D+2 | 小数值     |





### 日期和时间类型

| 类型      | 格式                                      | 用途        |
| --------- | ----------------------------------------- | ----------- |
| DATE      | YYYY-MM-DD                                | 日期值      |
| TIME      | HH:MM:SS                                  | 时间值      |
| YEAR      | YYYY                                      | 年份值      |
| DATETIME  | YYYY-MM-DD HH:MM:SS                       | 日期+时间值 |
| TIMESTAMP | 当前时间减去1970-01-01 00:00:00得到的秒数 | 时间戳      |





### 字符串类型

| 类型    | 用途           |
| ------- | -------------- |
| CHAR    | 定长字符串     |
| VARCHAR | 变长字符串     |
| BLOB    | 二进制文本数据 |
| TEXT    | 文本数据       |

char(n)和varchar(n)：char表示最多存储n个字符，varchar表示不定长存储若超过n个字符也能存储



# MySQL

MySQL 是一个关系型数据库管理系统，开源免费，且易扩展，是当前最流行的关系型数据库管理系统之一，在 Java Web 应用方面的应用十分广泛。其默认端口为 **3306**。

![image-20210119164302804](C:\Users\Steven\Desktop\CS-Note\数据库\pic\mysql体系结构.png)



## 基本架构



### 连接池（网络接入层）

作用：主要负责连接管理、授权认证、安全等



连接池的目的：每个客户端连接都对应服务器的一个线程，为了避免每条连接都要创建和销毁产生巨大的开销，因此服务器缓存了线程，连接池的目的就是为了减少系统开销



### 查询处理器（服务层）

作用：服务层为MySQL的核心层，查询解析、SQL执行计划分析、SQL执行计划优化、查询缓存都在这一层



SQL语句在服务层的具体执行流程

* 查询缓存：解析查询之前会先检测查询缓存，如果能找到相应的查询，则不必进行查询解析、优化和执行的过程，直接将缓存的结果集返回
* 解析器和预处理器：MySQL会将查询语句解析成一个数据结构解析树，这个过程会进行根据语法规则来验证和解析，检查SQL中是否存在错误的语法，查询的数据表或者数据列是否存在
* 查询优化器：优化器将其转化为查询计划，优化器的作用就是从一条查询中的多种执行方式找到一种最优的方式，优化器并不关心使用的什么存储引擎，但是存储引擎对优化查询是有影响的
* 查询引擎：完成解析和优化后，会生成相应的执行计划，查询引擎根据执行计划的指令调用存储引擎接口得出结果



### 存储管理器（存储引擎层）

作用：作为MySQL中数据的存储和提取，服务器通过存储引擎接口来通信，屏蔽了不同存储引擎的差异。MySQL采用了插件式的存储引擎，每种存储引擎有不同的特点，根据不同的业务特点，选择最合适的存储引擎





### 物理部分（系统文件层）











## 索引

### 概念

什么是索引？为什么使用索引？

索引用于快速找到某个列中有一特定值的行，当表中的记录过大，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找到相关的行，查询所花费的时间会增大。如果表中查询的列有一个索引，MySQL就能快速到达一个位置去搜索数据文件，而不必查看所有数据，那么对于查询数据库将会节省很多时间

本质：索引的本质数据结构，在特定场景下利用适合的高效的数据结构来让查询变得高效（空间换时间）





### 分类

按原理分类，索引分为以下几类

* 顺序索引
* 散列索引
* 位图索引



从MySQL的应用角度，索引分为以下几类

* 单列索引
* 联合索引
* 全文索引
* 空间索引



顺序索引中，又有以下几种分类

* 聚集索引/非聚集索引
* 稠密索引/稀疏索引
* 多级/单级索引
* 多码/单码索引



顺序索引中，按索引文件分类

* 索引顺序文件
* B+树索引文件



**聚集索引/非聚集索引**

搜索码：是任何一个属性或者属性的集合，它没必要是主码，甚至是超码。

索引结构：每个索引记录都包含搜索码及其搜索码相关联的记录

聚集索引：也叫做主索引，被索引文件顺序与索引结构中搜索码的顺序相同

非聚集索引：也叫做辅助索引，被索引文件顺序与索引结构中搜索码的顺序不同



**稠密索引/稀疏索引**

稠密索引：每个搜索码值都有一个索引项，辅助索引一定是稠密索引

稀疏索引：只为搜索码的某些值建立索引项





**索引顺序文件**

假定所有文件按某些搜索码顺序排序，这种搜索码上有聚集索引的文件成为索引顺序文件

![image-20210120180835365](C:\Users\Steven\Desktop\CS-Note\数据库\pic\顺序索引文件.png)





### 实现原理

**磁盘结构**

* 数据库的数据存储在磁盘，以实现持久化
* 硬盘划分为磁头（Heads）、柱面（Cylinder）、扇区（Sector）
* 磁头：每张磁片正反两面各有一个磁头，一个磁头对应一张磁片的一个面
* 柱面：所有磁片中，**半径相同的同心磁道**构成柱面
* 扇区：将磁道划分为若干个小的区段，就是扇区

![](https://img-blog.csdn.net/2018071121421234?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NzAzNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180711214220194?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NzAzNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

![](https://img-blog.csdn.net/20180711214524523?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NzAzNjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

* 磁盘最小的存储单元为扇区，而数据就存储在这里，扇区的大小一般为512kb，具体大小由磁盘厂商定制

**磁盘读写操作**

磁盘的读写是根据主机访问磁盘地址实现的（磁头号、柱面号、扇区号），读写操作过程如下

1. 寻道：磁盘控制器将磁盘地址送到磁盘地址寄存器中，便产生了寻道命令，控制器选择指定的磁头移动到指定的柱面。
2. 旋转等待操作：盘片旋转时，会将扇区地址和磁盘地址寄存器进行比较找到符合的扇区
3. 读写操作：磁盘符合信号送给磁盘控制器，就开启读写控制。

**磁盘性能指标**

磁盘读写操作需要经过寻道、旋转等待、读写操作

因此响应时间=排队延迟+控制器时间+寻道时间+旋转等待时间+数据传输时间

* 一次存储时间大约需要10ms，非常慢！
* 磁盘读取数据，是以块为单位载入内存当中



**数据库文件**

假设数据库表为一个文件，这张表的每一条记录为定长记录，这些记录都会映射到磁盘块上，这个记录数如果很庞大，用户需要查询数据时，从头到尾读取时，需要把相应的磁盘块载入到内存中，这样查询的时间大多都耗费在I/O操作上，为了提高性能，采用索引的方式，建立一个数据结构包含了索引号和对应记录的指针，索引号按顺序排列，查询数据库时只需要载入索引表，进行二分查找，找到相应的索引号对应的记录，然后载入记录所在的磁盘块到内存即可，由于索引表比记录表小的多，那么就能够减小I/O操作消耗的时间，提高性能。



**多级索引**

当索引表过大时，查询的时间又会消耗在I/O操作上，采用类似的思路对索引表再建立索引的方式，先对外层索引记录下一级索引的范围，采用二分的方式，就能进一步减少I/O操作时间

![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\多级索引.png)

**二叉搜索树**

多级索引最大的缺点是不灵活，（数组）插入和删除和操作时间复杂度过高，为了在数据插入和删除的情况下仍然能保持其执行效率，采用二叉搜索树的方式来存储索引，但是二叉搜索树有可能退化成链表，查询时间复杂度就又变高



**平衡树AVL和红黑树**

为了使二叉树平衡，采用平衡二叉树来作为索引的数据结构，AVL树是高度平衡的二叉树，通过左旋和右旋来使得每个节点的平衡因子不超过1，为了维持这个性质，会耗费更多的时间来调整树的结构。

// TODO 红黑树



**B树**

B树是一颗多路平衡树，一颗m阶的B树定义如下

1. 一个节点最多有m-1个关键字，最多m个孩子结点
2. 非根节点至少$\lceil m/2 \rceil - 1$个关键字
3. 除非整棵树只有一个结点，否则根结点必须至少包含两个指针
4. 所有节点的关键字都按从小到大顺序排列
5. 所有叶子节点都位于同一层

通过分裂、合并、上移、下移操作来完成树的平衡

B树与红黑树相比是矮（深度小）胖（一个节点存储的关键字多）

每个节点有多个关键字，将一个节点设计为一个页（磁盘每次读取到大小相等的块到内存，每个块成为一个页），这样节点只需一次IO就可以完全载入，利用B树矮的特点，就可以减少IO读写来提高性能



**B+树**

结构与B树类似，除此之外还有以下要求

* 每个叶子节点都存有相邻叶子节点的指针，按叶子节点的关键字从小到大顺序连接
* 非叶子节点不存数据，只有索引，叶子节点存储数据和索引

使用B+树的原因

* B+树的非叶子节点由于不存储数据，在与B树节点相同的大小下，能存储更多的关键字，与B+树相比深度会更矮，IO操作代价会更低
* 由于数据都存在叶子节点，叶子节点的深度都相同，因此每次查询时更加稳定
* 由于叶子节点有到相邻节点的指针，因此范围查找时不用从根节点出发重新遍历，而是直接从叶子节点出发，减少了IO操作，有效提高了范围查找的效率



[MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)





**MySQL索引实现**

主要分两类索引

* 顺序索引
* 散列索引





### 应用

```mysql
SHOW INDEX FROM table_name;
```

![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\showIndex.png)

* Non_unique：是否为唯一索引
* Key_name：索引名字
* Column_name：列的名字
* Index_type：索引的类型



#### 单列索引

一个索引只包含一个列

**主键索引**

特殊的索引，不允许有空值。InnoDB下建表时会默认建立主键索引



**唯一索引**

唯一索引的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。

```mysql
ALTER TABLE table_name ADD UNIQUE(column);
```



**普通索引**

最基本的索引，没有任何限制。

```mysql
ALTER TABLE table_name ADD INDEX index_name(column);
```



#### 联合索引

在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时遵循最左前缀集合。

回表：先索引扫描，然后通过主键去取索引中未能提供的数据，比如设置联合索引(A,B)，SELECT A, B, C FROM TABLE WHERE A = 1, B = 2，A，B可以直接通过索引取得数据，但是C需要通过主键取表中取得数据



**用法**

```mysql
ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3)
```

**意义**

1. 减少开销。建一个联合索引（col1，col2，col3）实际相当于建了（col1），（col1，col2），（col1，col2，col3）三个索引。对于大量数据的表，使用联合索引会大大的减少开销。
2. 覆盖索引。如果查询的列和联合索引的列相同，那么可以直接通过遍历索引取得数据，而无需回表。减少了IO操作
3. 效率高。索引列越多，通过索引筛选出的数据越少。



**使用场景**

联合索引的目的就是为了提高存在多个查询条件情况下的效率



**最左匹配原则**

联合索引是一个有序的元组，假如索引列分别为A，B，C，顺序也是A，B，C

* 查询的时候，如果查询【A】【A,B】【A,B,C】那么可以通过索引查询
* 如果查询的时候，采用【A,C】那么只能用【A】索引
* 如果查询的时候【B】【B,C】【C】，最左前缀不匹配，那么后面的索引就用不到了





#### 全文索引

只有在MyISAM引擎上才能使用，只能用于CHAR,VARCHAR,TEXT类型字段。用于在一堆文字中，通过某个关键字找到该字段所属的行。

索引一经创建不能修改，只能删除重建。

```mysql
ALTER TABLE table_name ADD FULLTEXT(column);
查找条件使用MATCH AGAINST
```

InnoDB存储引擎再MySQL5.6.4中也开始支持全文索引





#### 空间索引

空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有四种，GEOMETRY,POINT,LINESTRING,POLYGON，创建空间索引时，使用SPATIAL关键字。要求存储引擎为MyISAM，创建空间索引的列，必须将其声明为NOT NULL。





#### 哈希索引

InnoDB存储引擎使用哈希算法对字典进行查找，其冲突机制采用链表方式，哈希函数采用除法散列方式，哈希索引能以O（1）的时间来查找，但是无法用于排序或者分组，且只能支持精确查找，不支持部分或者范围查找，同时InnoDB存储引擎有一个特殊功能叫做“自适应哈希索引”，当某个索引值使用非常频繁时，就会在B+Tree索引之上再创建一个哈希索引





### 评价

使用索引的优缺点

* 减少了查询需要扫描的数据量
* 将服务器的随机IO变成了顺序IO
* 减少服务器的排序操作和创建临时表的速度（加快了GROUPBY和ORDERBY操作）

缺点

* 索引会带来额外的空间存储，其次在更新、删除操作，需要维护索引，带来了额外的时间开销



#### 使用原则

为什么不对表中每一个列创建一个索引呢？

* 创建索引和维护索引要耗费时间，这种时间会随着数据量的增加而增加
* 索引需要占用空间

不是每一个字段都设置索引就好，也不是索引越多越好，而是需要合理的使用

* 对于需要经常更新的表需要避免使用过多的索引，对于经常需要查询的字段应该创建索引
* 数据量小的表不必要使用索引，因为数据较少，查询全部数据花费的时间可能比遍历索引的时间还要短，索引就不会产生优化效果
* 在一同值少的字段上不要建立索引，比如学生表性别字段上只有男女两个不同的值。



#### 设计原则

* 适合索引的列是出现在where子句中的列，或者连接子句中指定的列
* 使用短索引，对过对长字符串列进行索引，应该指定一个前缀长度，这样能节省大量索引空间
* 不要过度索引。







#### 失效场景

* 使用负向查询（not，not in，<>，!=）
* 出现字符串或者数据的比较
* 数据类型出现隐式转换
* 使用了正则表达式
* 对索引列进行函数运算
* 使用联合索引不满足最左前缀匹配原则
* 以%开头的like查询
* MySQL估计使用索引比全表扫描慢





### 优化

* 使用前缀索引
* 使用联合索引
* 使用覆盖索引
* 使用聚簇索引
* 删除重复和冗余的索引





前缀索引：对于较长的字符串来说，只索引字符串的前缀，可以大大节约索引的空间，提高索引的效率，但是这样会降低索引选择性

索引选择性：值为不重复的值/所有的值，因此值范围为0-1，1表示该列所有值没有重复，因此唯一索引效率会高



聚簇索引：聚簇索引指搜索码与被索引文件对应的索引码顺序相同，也就是说被索引文件行记录是按搜索码的排序顺序存储的，InnoDB使用主键进行聚簇索引，同时叶子结点存放着整张表的行记录，如果没有主键就会选择一个唯一非空的索引，如果还没有就会生成一个隐式的主键进行聚簇索引，而非聚簇索引的索引表实际上记录的地址就是主键，查找到主键后，会根据主键再一次进行索引，拿到数据



覆盖索引：即索引包含了需要查询的字段的值。使用覆盖索引可以减少IO次数，提升查询数据的速度







## 事务



### 概念

事务是一组sql语句组成的执行单元，这个单元要么都执行，要么都不执行



### 特性

事务具有四大特性ACID

* Atomicity原子性：事务像一个原子一样，是一个不可分割的逻辑单元
* Consistency一致性：从一个一致性的状态转移到另一个一致性的状态，这个一致性状态既指系统的状态满足数据的完整性约束，即数据库的完整性没有遭到破坏
* Isolation隔离性：并发执行的事务互不干扰
* Durability持久性：事务一旦提交，对数据库的改变就是持久的，任何事务或者系统故障都不会导致数据丢失



事务的最终目的是为了保证一致性，而保证一致性的前提就是事务能够拥有像原子一样的特性，执行单元的sql语句要么都执行，要么都不执行，而对数据一致性的破坏主要来源于事务的并发控制和事务故障或系统故障，通过并发控制和日志恢复技术使得事务具有了隔离性和持久性，因而就保证了数据的一致性



### 并发问题

数据库的并发问题主要有两种**并发故障**和**故障异常**



**丢失更新**

![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\丢失更新.png)



* 事务A和事务B都读取到了一样的数据，事务B先对数据进行了更新并提交，而事务A之后对之前读的数据进行了更新操作并提交，导致了事务B好像对数据的更新发生了丢失





**脏读**

![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\脏读.png)

* 指事务A对数据更新过程中，事务B读取了A的值，但是之后事务A回滚，导致了事务B读取的是事务A未提交的脏数据







**不可重复读**

![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\不可重复读.png)

* 事务A读取了某个数据，事务B之后对数据更新并提交，导致了事务B之后读取到了与之前不一样的结果



**幻读**

![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\幻读.png)



* 事务A读取了某个范围的数据，事务B对这个范围内插入了新的数，事务A再次读取时发现结果与第一次读取的结果不相同







事务执行的过程可以简化如下

* 系统为每个事务开辟一个私有工作区
* 事务读操作将从磁盘中拷贝数据项到工作区中，在执行写操作前所有的更新都作用与工作区的拷贝
* 事务的写操作将数据输出到内存的缓冲区，等到合适的时间再由缓冲管理器将数据写入磁盘



由于数据库存在立即修改和延迟修改，所以在事务执行过程中可能存在以下情况

* 在事务提交前出现故障，但是事务对数据库的部分修改已经写入磁盘数据库中，导致了事务的原子性遭到破坏
* 在系统崩溃前事务已经提交，但数据还在内存缓冲区中，没有写入磁盘。刺痛恢复时将丢失此次已提交的修改。这是对事务持久性的破坏







### 隔离级别

SQL标准为事务定义了不同的隔离级别，从低到高依次是

* 读未提交（READ UNCOMMITTED）
* 读已提交（READ COMMITTED）
* 可重复读(REPEATABLE READ)
* 串行化（SERIALIZABLE）



事务的隔离级别越低，可能出现的并发异常越多，以下为不同隔离级别下，可能导致的并发问题



| 隔离级别         | 脏读 | 丢失更新 | 不可重复读 | 幻读 |
| ---------------- | ---- | -------- | ---------- | ---- |
| READ UNCOMMITTED | √    | √        | √          | √    |
| READ COMMITTED   |      | √        | √          | √    |
| REPEATABLE READ  |      |          |            | √    |
| SERIALIZABLE     |      |          |            |      |



**RU实现**

* 读数据项不加锁，因此每次读取的都是数据项的最高版本
* 写数据项加行级锁
* 可能导致不可重复读、幻读、丢失更新、脏读



**RC实现**

* 读采用的是MVCC，每次使用SELECT语句会生成ReadView，读取的是当前快照的最高版本
* 写数据项加行级锁（采用一级封锁协议，只有在事务结束才释放所有锁）
* 可能导致不可重复读、幻读、丢失更新



**RR实现**

* 读采用的是MVCC，第一次使用SELECT语句会生成ReadView，以后每次读都是该快照的最高版本
* 写数据项加行级锁
* 可能导致幻读



**序列化实现**

* 读写都加锁，采用的是严格两阶段封锁协议，一阶段申请，一阶段释放





## 并发控制

### 介绍

并发控制技术是现实事务隔离性以及不同隔离级别的关键，按照不同的策略可以分为乐观并发控制和悲观并发控制，乐观并发控制是指对于并发执行可能冲突的操作，假定其不会真的发生冲突，允许并发执行，直到真正冲突时采取解决冲突，比如事务回滚。悲观并发控制是指对于并发执行可能冲突的操作，假定其必定发生冲突，通过让事务等待或者中止的方式使并行的操作串行执行







### 悲观并发控制

悲观并发控制主要有两种措施，基于**封锁的并发控制**和基于**时间戳的并发控制**



#### 基于封锁的并发控制

核心思想是就是对于并发可能发生的冲突操作，通过锁的操作使他们互斥执行，该并发控制要求了每个事务要根据自己对数据项进行的操作类型申请适当的锁，该事务会将请求发送给事务并发控制器，事务只有在并发控制器授予所需的锁才能继续其操作



#### 锁的概念

锁通常分为共享锁和排他锁

* 共享锁（S）：事务对数据项加共享锁，那么其他事务只能对数据项加共享锁，但是不能加排它锁
* 排它锁（X）：事务对数据项加排它锁，那么其他事务既不能对数据项加共享锁，也不能加排它锁



**锁相容**

对于锁类型，可以定义一个相容函数，假设事务A对数据项加A类型的锁，而事务B对该数据项上拥有B类型的锁，但是事务A可以立即获得B类型的锁，我们称A类型锁和B类型锁是相容的，对于S锁和X锁有如下关系

|      | S     | X     |
| ---- | ----- | ----- |
| S    | TRUE  | FALSE |
| X    | FALSE | FALSE |





#### 死锁和饥饿

* 死锁：事务A在等待事务B持有锁的数据项，而事务B在等待事务A持有锁的数据项，这种情况就会发生死锁，数据库死锁的解决办法主要有死锁预防和死锁检测和解除
* 死锁预防：本质就是破坏死锁的一个或者多个必要条件
  * 破坏请求和保持条件：静态资源分配法，每个事务开始之前封锁它的所有数据项，要么一次性封锁，要么不封锁
  * 破坏循环等待条件：采用有序资源分配法，给每个数据项按序编号，要求事务只能按序来申请数据项的封锁
* 死锁检测和恢复
  * 采用锁超时机制，如果超时则事务回滚
* 饥饿：事务A对数据项持有共享锁，同时事务B对数据项申请加排它锁，那么事务B就必须等待事务A释放共享锁，如果此时新的事务在事务A完成之前授予锁，那么会造成排它锁的饥饿现象



#### 锁的授权

通过授权加锁的方式来避免事务饥饿现象，当事务A申请对数据项加M锁，并发控制管理器授权加锁的条件是

* 不存在数据项上持有与M锁冲突的锁的其它事务
* 不存在等待对数据项加锁先于事务A申请加锁的事务

因此，一个加锁请求就不会被其后的加锁申请阻塞



#### 封锁协议

**一级封锁协议**

* 事务A对数据项修改时，需要加X锁，直到事务结束才释放
* 避免了丢失更新，但是不能避免不可重复读和脏读



**二级封锁协议**

* 在一级封锁协议基础上增加了读取数据项前，需要加S锁，读取完之后才能释放S锁
* 避免了丢失更新、脏读，但是不能避免不可重复读



**三级封锁协议**

* 在二级封锁协议基础上，规定S锁要在事务结束后才能释放
* 避免了丢失更新、脏读、不可重复读



#### 两阶段封锁协议

两阶段封锁协议提出了每个事务分两个阶段提出加锁和解锁的申请

* 增加阶段：事务可以获得锁，但是不能释放锁
* 缩减阶段：事务可以释放锁，但是不能获得锁
* 对于任何事务，在调度中该事务最后获得锁的位置称为封锁点
* 两阶段封锁协议并不能保证死锁不发生



**严格两阶段封锁协议**

![](C:\Users\Steven\Desktop\CS-Note\数据库\pic\严格两阶段封锁协议.png)

* 在两阶段封锁协议中，级联回滚可能会发生，例如上图，T5\T6事务遵循两阶段封锁协议，但是当T7在read(A)的时候发生了故障，导致了T5\T6发生了级联回滚
* 级联回滚可以通过将两阶段封锁协议修改为严格两阶段封锁协议来避免级联回滚的发生
* 该协议特别要求了事务持有的所有排他锁必须在事务提交后才能释放。这个要求保证未提交事务所写的任何数据在该事务提交之前均以排他方式加锁，防止其他事务读这些数据



**强两阶段封锁协议**

* 该协议要求在事务结束之前不能释放任何锁



#### 读写锁和意向锁

* 使用意向锁可以支持多粒度封锁
* 如果没有意向锁，当有人使用行锁对表中某个记录进行更新，而另一个请求需要对全表进行更新，这样就需要对所有行是否锁定进行扫描，这种情况下效率非常低，引入意向锁当有人对某个记录进行更新时，先为表添加意向锁，然后再为表中的行记录添加读写锁，如果有人请求对全表进行更新就只需要判断该表是否存在意向锁
  * 意向共享锁（IS）：事务想要获取某些记录中的共享锁，需要在表上加入意向共享锁
  * 意向互斥锁（IX）：事务想要获取某些记录中的互斥锁，需要在表上加入意向互斥锁



|      | X     | IX    | S     | IS    |
| ---- | ----- | ----- | ----- | ----- |
| X    | FALSE | FALSE | FALSE | FALSE |
| IX   | FALSE | TRUE  | FALSE | TRUE  |
| S    | FALSE | FALSE | TRUE  | TRUE  |
| IS   | FALSE | TRUE  | TRUE  | TRUE  |

* IX和IS锁兼容，因为意向锁只是表示想要对表进行加锁，并不会真正加锁
* S锁只与S/IS锁兼容



#### 封锁粒度



MySQL主要提供了两种封锁粒度：行锁和表锁



**表锁**

* 是MySQL中封锁粒度最大的锁定机制，该机制最大的特点就是实现简单，带来的系统负面影响小，由于表级锁一次会将整个表锁定，很好地避免了死锁的问题
* 锁的大粒度同时也带来了性能问题，首先资源争用的概率会变大，导致并发度大打折扣

**行锁**

* 最大的特点就是锁定对象的粒度小，进而发生锁定资源争用的概率回小，并发度也会变大
* 虽然在并发处理能力上有较大优势，但是行锁每次获取和释放锁做的事情多，消耗自然会变大，此外，行锁也容易发生死锁



#### MySQL行锁算法

* Record Lock：单个行记录上的锁
* Gap Lock：间隙锁，锁定一个范围，但是不包含记录本身
* Next-Key Lock：Gap Lock + Record Lock，锁定一个范围，且锁定记录本身



**Record Lock**

```mysql
SELECT ... FOR UPDATE
```

锁定了一个记录上的索引，而不是记录本身

如果不存在索引，InnoDB会自动在主键上创建一个聚簇索引



**Gap Lock**

```mysql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

锁定索引的间隙，但是不包括索引本身，执行该语句，那么就不能插入15，间隙锁锁定的是一个范围，而不是该区间的每一条数据



**Next-Key Lock**

MVCC无法解决幻读问题，在RR隔离级别下，使用MVCC+该锁可以解决幻读的问题，当事务使用FOR UPDATE\UPDATE\LOCK IN SHARE MODE操作时，就会获取该记录行的Next-Key Lock





#### 基于时间戳的并发控制

**原理**

* 给每个事务赋予一个时间戳，这个时间戳可以是系统时钟也可以是一个不断累加的计数器的值，事务回滚时会为每个事务赋予一个新的时间戳，先开始的事务时间戳小于后开始的事务
* 每个数据项都包含了两个时间戳字段
  * W-ts：成功执行写操作的所有事务的最大时间戳
  * R-ts：成功执行读操作的所有事务的最大时间戳
* 时间戳排序有如下规则
  * 假设事务发起读操作，时间戳为TS
  * 若TS < W-ts，则T需要读的数据已被覆盖，事务回滚
  * 若TS >= W-ts，则执行读操作，同时把R-ts设置为TS与R-ts的最大值
  * 假设事务发起写操作，时间戳为TS
  * 若TS < R-ts，则事务回滚
  * 若TS>=W-ts，则执行写操作，同时将W-ts设置为TS



### 乐观并发控制



#### MVCC

* 快照隔离是MVCC的一种实现方式
* 其核心思想就是数据库为每个数据项维护多个版本（快照），每个事务只对属于自己的私有快照进行更新，在事务提交前进行有效性检查，使事务正常提交更新或者失败回滚
* 由于快照隔离导致事务不可见其它事务对数据项的更新，为了避免丢失更新问题，可以采用以下方案解决
  * 先提交者获胜：判断是否有其他事务已经将更新写入数据库，如果有则事务回滚否则提交
  * 先更新者获胜：通过锁机制保证了第一个获得锁的事务提交其更新，之后试图更新的事务中止
* 由于快照隔离对并发执行的事务可能发生的冲突没有采取措施，而是当写入数据库才进行冲突检测，所以这是一种乐观的并发控制



**MVCC必要性**

* 实现并发手段方式主要有两种**锁**和**多版本**
* 多版本比起锁最大的优势就是读不加锁、读写可以并发，极大提高了系统的并发能力



**undo日志**

undo日志主要是为了存储未提交的事务中旧版本的数据，当事务回滚时或者数据库崩溃，就可以利用undo日志恢复，因此undo日志可以保障未提交的事务不会对数据库的ACID产生影响

MVCC使用的快照存储在了undo日志中，该日志通过回滚指针把数据行的所有快照连接起来





**版本号**

* 系统版本号，是一个递增的数字，每开始一个新的事务，系统版本号就会增加
* 事务版本号：事务开始时的系统版本号





**隐藏的行**

![](https://upload-images.jianshu.io/upload_images/8485522-d0b030b1f3e2783d.png?imageMogr2/auto-orient/strip|imageView2/2/w/733/format/webp)

InnoDB下，每个数据行都隐藏3个列

* DB_TRX_ID：6个字节，每处理一个事务，值加一
* DB_ROLL_PTR：7个字节，记录了当前行在undolog的回滚段的位置
* DB_ROW_ID：6个字节，如果声明了主键，那么就是该字段，否则会自动生成一个隐藏的主键，该字段有一个delete_flag来记录当前行是否被删除





**ReadView**

四种隔离级别中，RU是总是读取数据行的最新记录，串行化采用加锁的方式，因此不需要MVCC，因此MVCC运行在了RC和RR中，解决一致性读的问题采用了版本链，其核心问题就是版本链的哪些版本对当前事务可见



* 基本结构

```
ReadView {
    creator_trx_id    // 创建ReadView的事务ID
    low_limit_id      // 所有的事务ID大于low_limit_id对当前事务都不可见
    up_limit_id       // 所有的事务ID小于up_limit_id对当前事务都可见
    ids               // 未提交的事务
    ...
}
```





**RR下生成ReadView**

生成的原则就是事务开始后的第一条SELECT语句生成ReadView，直到事务结束时，读取的数据行都是该版本

![](https://ww1.sinaimg.cn/large/c3beb895ly1g49zfpi9jqj20h90gz0tp.jpg)

* 第一条select发生在了事务B更新数据行之前，因此无法读到事务更新的数据



![](https://ww1.sinaimg.cn/large/c3beb895ly1g49zqz1t94j20h90gz755.jpg)

* 第一条select发生在了事务B更新数据行后，因此读到是事务B更新的数据



**RC下生成ReadView**

生成的原则就是每一条SELECT语句都生成一个ReadView

* ReadView每次保存的是当前活跃的事务ID列表，称之为m_ids，事务ID的大小决定了事务开始的先后顺序，其最小值为up_limit_id，最大值为low_limit_id，根据ID的大小我们可以决定版本记录的可见性
* 如果被访问的数据行版本号小于up_limit_id，说明这个版本的事务在ReadView生成之前就已经提交，因此该版本可以被当前事务访问
* 如果访问的数据行版本号大于low_limit_id，说明这个版本的事务在生成ReadView之后才开始的，因此该版本不可以被当前事务访问，需要从版本链中找前一个版本再进行判断
* 如果访问的数据行版本号在[up_limit_id, low_limit_id]之间，说还需要进一步判断活跃事务ID列表m_ids是否包含了该版本号，如果存在说明了这个版本号对应的事务在生成ReadView时是活跃的事务，需要找版本链前一个版本再次进行判断，如果不包含该版本号，说明了生成ReadView时是已提交的事务，该版本可以被访问
* 最后还需要判断delete_flag是否为true，true则该记录已被删除，不返回，false表示该记录可以安全返回



**快照读**

即普通的读，在RC和RR中使用的是MVCC和undo log实现的

```mysql
SELECT * FROM TABLE ...
```





**当前读**

通过RECORD LOCK和GAP LOCK来实现的

```mysql
SELECT * FROM TABLE WHERE ? LOCK IN SHARE MODE
SELECT * FROM TABLE WHERE ? FOR UPDATE
INSERT
DELETE
UPDATE
```



[MVCC概述](https://mp.weixin.qq.com/s/R3yuitWpHHGWxsUcE0qIRQ)

[MVCC整理](https://chenjiayang.me/2019/06/22/mysql-innodb-mvcc/)





### 日志



#### redo

在InnoDB存储引擎中，事务日志通过重做日志文件和InnoDB存储引擎日志缓冲来实现，当开始一个事务时，会记录一个日志序列号LSN，当事务开始执行时，会往InnoDB存储引擎的日志缓冲里插入事务日志。当事务提交时，必须将InnoDB存储引擎的日志缓冲写入磁盘，这种写数据前先写日志的方式称为预写日志方式WAL

InnoDB存储引擎通过WAL来保证了数据的完整性



#### undo

回滚日志保存了事务开始前的版本，当事务执行失败或者回滚时可以利用回滚日志将数据回滚到修改之前，回滚日志保存在一个回滚段中，回滚日志只能提供逻辑恢复而非物理恢复，也就是说回滚日志只能将数据恢复到修改之前，所有修改都将被逻辑取消，当执行INSERT/DELETE，回滚后会进行相反的操作DELETE/INSERT，而更新UPDATE，会将更新前的结果保存到回滚段，回滚时会执行该语句，回滚日志还提供了MVCC的读操作



#### bindo

用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现了主从同步，用于数据库基于时间点的完成，binlog不会记录不修改数据的语句，bindo有3种格式



**row**

* 仅保存记录修改的细节，不记录sql语句的上下文环境

* 优点：能非常清晰的每行数据的修改细节
* 缺点：由于需要记录每行数据的修改细节，不需要记录上下文信息



**statement**

* 每一条会修改的sql语句都会记录在binlog中
* 优点：只需要记录执行语句的细节和上下文环境，避免了记录每一行的记录
* 优点：为了保证保证sql语句能在从库上正确执行，必须记录上下文信息，保证所有语句都能在从库上正确执行





**mixed**

* 结合了row和statement
* 遇到表结构的更改就会以statement模式来记录，如果SQL语句是update和delete等修改则使用row模式





[bindo](https://zhuanlan.zhihu.com/p/150105821?from_voters_page=true)





## 高级部分



### 读写分离







### 主从复制







### 分库分表







### 水平切分





### 垂直切分





### 优化









## 存储引擎

### InnoDB

InnoDB是第一个完整支持ACID事务的MySQL存储引擎，实现了四个标准的隔离级别，默认级别为RR，行锁设计，支持MVCC，主索引是聚簇索引，在索引中保存了数据，从而避免了直接读取磁盘，因此对查询性能有很大的提升，内部做了很多优化，包括从磁盘读取数据时采用了可预测性读、能加快读操作并且自动创建自适应哈希索引、能够加快插入操作的插入缓冲区等。





### MyISAM

设计简单，数据以紧密格式存储，对于只读数据或者表比较小、可以容忍修复操作，依然可以使用它。提供了大量的特性，包括压缩表、空间数据索引，不支持事务，不支持行锁，只能对整张表加锁，读取时会对需要读取到的所有表加共享锁，写入时则对表加排它锁，当在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入，可以手动或自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的





### 比较



* 事务：InnoDB支持索引
* 并发：MyISAM只支持表级锁，InnoDB支持行级锁
* 外键：InnoDB支持外键
* 备份：InnoDB支持在线热备份
* 索引：MyISAM支持空间索引





# 问题集

**索引**

那你能说说索引吗？它是用什么样的数据结构实现的？ 

那你说说B+树的高度以及查找的时间复杂度？ 

那这里为什么不用B树？B树和B+树的区别是什么？ 

MySQL的索引(B+和B树的区别，为啥用B+)；

索引的数据结构（B+树）、索引优缺点 

索引作用？索引的数据结构

为什么索引使用B+树结构，而不是B树 {B+树叶子结点}

为什么索引使用B+树结构，而不是[红黑树]() ： { 磁盘预读取 、[红黑树]()高度 }

mysql索引类型

聚簇索引和非聚簇索引

联合索引

联合索引最多多少个字段

 在设计联合索引需要注意什么 

 联合索引最左原则的底层原理 

联合索引底层原理+最左匹配原则？

最左匹配原则 

索引失效什么情况？

怎么设计索引？

 说说索引失效场景：最左匹配LIKE % 、函数（还有吗） 

最左前缀原则、索引优化 

聚簇索引、覆盖索引 

聚簇索引是什么？

innodb是什么索引？

查字典是什么索引？

 聚簇索引和非聚簇索引如何加锁？ 

 (蒙了蒙了，彻底蒙了。。。。)

Innodb，B+树，聚簇索引和非聚簇索引区别 

 一千万条数据，问 b+ 树大概多高 

聚簇索引和非聚簇索引区别？ 主键索引和二级索引了解吗？  

为什么不对每个列创建索引呢？

mysql索引，再谈了谈高并发下B+树的优越性

mysql的查询，怎么判断有没有使用到索引（explain）

索引作用，失效的场景 

```
索引用来在大量数据中快速定位到我们想要查找的数据` 
`1``.like 以%开头，索引无效`
`2``.or语句前后没有同时使用索引`
`3``.单独引用复合索引里非第一位置的索引列`
`4``.数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为``int``型`
`5``.当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效
```



非聚簇索引存了啥？如何避免回表?

讲讲数据库的索引？

你了解什么索引？什么时候索引会失效？

什么时候用哈希索引

一级索引二级索引（簇族索引和非簇族索引区别，答了一个物理顺序和逻辑顺序一致，问就这样吗）

为什么是最左匹配

hash索引和b+索引分别用在哪个存储引擎

B+树和hash索引

怎么利用索引来进行查询

最左前缀

什么时候不该使用索引？

聚集索引和非聚集索引的区别 

数据库索引数据结构？各种索引失效的情况？









**事务**

什么是事务，事务的四大特性

深入一些 ： 为什么要有一致性 ？ AID不是已经保证了一致性了吗 ？ 

事务的实现原理

mysql是如何实现事务的（redo log，undo log和锁）

并发事务带来的问题 ： {  脏读 、 修改丢失 、 不可重复读 、 幻影读  }

数据库的事务隔离级别

 MySQL默认事物隔离级别：RR 

四种隔离级别说说吧，怎么实现的？

哪种会产生幻读？怎么解决？

脏读和幻影读的区别是什么？

RR能解决幻读吗？不能 

可重复读的隔离级别下如何保证不幻读 

Innodb 是如何解决幻读的

幻读和脏读的区别

脏读是更新时产生的？幻读是添加时产生的吗？





**并发控制和log**

【高频】 MVCC机制 

mvcc 的作用？解决什么问题？

 mysql 的 MVCC 以及是否解决幻读 

MVCC底层实现 

锁机制（悲观锁、乐观锁、行锁表锁、独占锁共享锁等等） 

 Innodb锁有什么：表锁、行锁、间隙锁、the next key lock 

 间隙锁能详细说说吗：谈到了一个范围加锁、开闭区间

MVCC、NK-Lock 

项目实际怎么解决幻读：锁 select for update 

WAL知道吗？哪个log用了这个？那顺便介绍下三大log?  

mysql的三大log?

redo log，bin log，undo log

binlog中都有啥？如何回滚，如何提交？ 



如果只有一条select语句，它加锁吗？ 

如果一条delete语句，如何加锁？ 

主键加锁吗？ 

mysql隔离级别（答了RC、RR、序列化，讲了一下innodb下RR级别咋解决幻读问题）

```
RR解决幻读
``间隙锁：对数据进行条件，范围检索时，对其范围内也许并存在的值进行加锁
``针对当前读，RR隔离级别保证对读取到的记录加锁 (记录锁)，同时保证对读取的范围加锁，新的满足查询条件的记录不能够插入 (间隙锁)，不存在幻读现象
```

 慢查询怎么处理？打开MySQL的慢查询日志，看看慢查询。 





**存储引擎**

Innode引擎都知道什么？ 

MyISAM 和 InnoDB的区别  ： {是否支持行锁 、 是否支持事务、 是否支持 MVCC 、 底层索引结构不同 }

你能说说MyISAM和InnoDB之间的一些异同点吗？ 







**数据库范式**

数据库范式 ？BCNF？第四第五范式？

数据库三大范式

数据库范式讲一下











**SQL**

关系型数据库和非关系型数据库区别？

char和varchar区别？

limit优化

explain中 rows type key extra字段的含义

count(1) count(*) count(列值)的区别

问你最后一个left join、right join和自然连接的区别

```
Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集` `left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。` `right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。` `自然连接，针对相同表的  mysql会根据多个表内的相同字段作为连接条件``条件：``1``)两张连接的表中列名称和类型完全一致的列作为条件``2``)多个列名相同时，列的值也要同时相同才会连接出查询数据
```





Having作用 

```
来过滤由GROUP BY语句返回的记录集(对分组后结果过滤，可以使用聚合函数如(max、min))``SELECT id, COUNT(course) as numcourse, AVG(score) as avgscore``FROM student``GROUP BY id``HAVING AVG(score)>=``80``;
```

 

一条sql执行很慢，怎么查？分析可能的原因？

主键是什么？

内连接 左连接 右连接

union与union all的区别

Explain

in和exist区别

模糊查询是怎么做的

mysql分页查询

MySQL和Redis的区别（各自使用的场景以及原因） 

 一条sql语句的查询流程





**高级**

mysql设计表时怎么去提高性能

当数据量变大了的时候，用MySQL该怎么解决（分库分表） 

主从复制、主从一致、分库分表等等问题

mysql主从复制的同步方式有几种？

mysql分库分表

Mysql主从复制

Mysql读写分离

数据库怎么优化

MySQL主从复制的原理？ 

MySQL的自增id换为UUID会有什么问题（这个没有理解到位 





**其它**

SQL注入了解吗？怎么防止？
